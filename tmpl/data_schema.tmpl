// hey-template version: {{{.Version}}}
// TEMPLATE CODE DO NOT EDIT IT.

package data

import (
    "crypto/md5"
    "crypto/sha256"
    "encoding/hex"
    "fmt"
	"github.com/cd365/hey"
	"sync"

	"{{{.PrefixPackage}}}/model"
	"github.com/vmihailenco/msgpack/v5"
)

type schema struct {
	// insertIgnoreColumns 插入数据需要忽略的字段列表
	insertIgnoreColumns []string
	// updateIgnoreColumns 更新数据需要忽略的字段列表
	updateIgnoreColumns []string
	// selectIgnoreColumns 查询数据需要忽略的字段列表
	selectIgnoreColumns []string

	// insertPermitColumns 插入数据允许查询的字段列表
	insertPermitColumns []string
	// selectPermitColumns 查询数据允许查询的字段列表
	selectPermitColumns []string

	// deleteFilter 删除数据的前提条件(删除的数据必须满足当前方法返回的条件)
	deleteFilter hey.Filter
	// updateFilter 更新数据的前提条件(更新的数据必须满足当前方法返回的条件)
	updateFilter hey.Filter
	// selectFilter 查询数据的前提条件(查询的数据必须满足当前方法返回的条件)
	selectFilter hey.Filter

	// deleteForbidMsg 删除不允许删除的数据(提示语)
	deleteForbidMsg string
	// updateForbidMsg 更新不允许更新的数据(提示语)
	updateForbidMsg string
}

type Tables struct {
    tableMap map[string]model.Table
    tableSlice []string
	{{{.MapListDefine}}}
}

var (
	// ats 方便当前包内某个表的实例对象引用其它表实例,特别是在自定义方法中(all tables)
	ats *Tables
)

func NewTables(
	{{{.MapListParams}}}
) *Tables {
	tables := &Tables{
		{{{.MapListAssign}}}
	}
	tables.tableMap = map[string]model.Table{
        {{{.MapListStorage}}}
    }
    tables.tableSlice = []string{
        {{{.MapListSlice}}}
    }
    if ats == nil {
        ats = tables
    }
    return tables
}

func AutoWay(defaultWay *hey.Way, options ...*hey.Way) *hey.Way {
	for i := len(options) - 1; i >= 0; i-- {
		if options[i] != nil {
			return options[i]
		}
	}
	return defaultWay
}

func (s *Tables) MAP() map[string]model.Table {
	length := len(s.tableMap)
	result := make(map[string]model.Table, length)
	for k, v := range s.tableMap {
		result[k] = v
	}
	return result
}

func (s *Tables) SLICE() []string {
	length := len(s.tableSlice)
	result := make([]string, length)
	copy(result, s.tableSlice)
	return result
}

func (s *Tables) WRITER(table model.Table, way ...*hey.Way) Writer {
	return &writer{
		table: table,
		way:   AutoWay(table.Add().Way(), way...),
	}
}

type Writer interface {
	Add(i interface{}, prefix ...func(add *hey.Add)) (int64, error)
	AddMust(i interface{}, prefix ...func(add *hey.Add)) error
	Del(where hey.Filter) (int64, error)
	DelMust(where hey.Filter) error
	Mod(where hey.Filter, modify interface{}, prefix ...func(mod *hey.Mod)) (int64, error)
	ModMust(where hey.Filter, modify interface{}, prefix ...func(mod *hey.Mod)) error
}

type writer struct {
	table model.Table
	way   *hey.Way
}

func (s *writer) Add(i interface{}, prefix ...func(add *hey.Add)) (int64, error) {
	tmp := s.table.Add(s.way).Except(s.table.AddExcept()...)
	if length := len(prefix); length > 0 {
		prefix[length-1](tmp)
	}
	s.table.AddAt(tmp, s.way)
	return tmp.Create(i).Add()
}

func (s *writer) AddMust(i interface{}, prefix ...func(add *hey.Add)) error {
	return hey.MustAffectedRows(s.Add(i, prefix...))
}

func (s *writer) Del(where hey.Filter) (int64, error) {
	return s.table.Del(s.way).Where(where).Del()
}

func (s *writer) DelMust(where hey.Filter) error {
	return hey.MustAffectedRows(s.Del(where))
}

func (s *writer) Mod(where hey.Filter, modify interface{}, prefix ...func(mod *hey.Mod)) (int64, error) {
	tmp := s.table.Mod(s.way).Except(s.table.ModExcept()...)
	if length := len(prefix); length > 0 {
		prefix[length-1](tmp)
	}
	s.table.ModAt(tmp, s.way)
	return tmp.Where(where).Modify(modify).Mod()
}

func (s *writer) ModMust(where hey.Filter, modify interface{}, prefix ...func(mod *hey.Mod)) error {
	return hey.MustAffectedRows(s.Mod(where, modify, prefix...))
}

// MakeSliceMap 提取字段并构建哈希表和哈希表键值切片
func MakeSliceMap[T any, K comparable](slice []T, key func(v T) K) (keys []K, maps map[K]T) {
	for _, item := range slice {
		tmp := key(item)
		if _, ok := maps[tmp]; ok {
			continue
		}
		if maps == nil {
			keys = make([]K, 0, 32)
			maps = make(map[K]T, 32)
		}
		maps[tmp] = item
		keys = append(keys, tmp)
	}
	return keys, maps
}

// MatchAssign 匹配赋值
func MatchAssign[T any, U any, K comparable](maps map[K]T, slices []U, key func(U) K, assign func(T, U)) {
	for i := range slices {
		tmp := key(slices[i])
		if value, found := maps[tmp]; found {
			assign(value, slices[i])
		}
	}
}

// QueryAssign 查询数据并匹配赋值
func QueryAssign[T any, U any, K comparable](maps map[K]T, query func() ([]U, error), key func(v U) K, assign func(a T, b U)) error {
	slices, err := query()
	if err != nil {
		return err
	}
	for i := range slices {
		tmp := key(slices[i])
		if value, found := maps[tmp]; found {
			assign(value, slices[i])
		}
	}
	return nil
}

// MakeCacheKey 根据参数构建缓存键
func MakeCacheKey(v interface{}) (string, error) {
	bts, err := msgpack.Marshal(v)
	if err != nil {
		return hey.EmptyString, err
	}
	md5Sum := md5.Sum(bts)
	sha256Sum256 := sha256.Sum256(bts)
	return fmt.Sprintf("CDE:%X%X", md5Sum, sha256Sum256), nil
}

// MakeCacheKeys 根据参数构建缓存键
func MakeCacheKeys(vvv ...interface{}) (string, error) {
	return MakeCacheKey(vvv)
}

// CacheMarshal 序列化待缓存的数据
func CacheMarshal(v interface{}) (string, error) {
	bts, err := msgpack.Marshal(v)
	if err != nil {
		return "", nil
	}
	return hex.EncodeToString(bts), nil
}

// CacheUnmarshal 反序列化已缓存的数据
func CacheUnmarshal(b []byte, v interface{}) error {
	bts, err := hex.DecodeString(string(b))
	if err != nil {
		return err
	}
	return msgpack.Unmarshal(bts, v)
}

// CacheKeyMutex 缓存互斥锁集合(预防缓存击穿)
type CacheKeyMutex struct {
	capacity int
	mutex    map[int]*sync.Mutex
}

// Get 根据缓存键根据一定的规则获取一把互斥锁(如果是分布式系统应该考虑 1.分布式锁, 2.使缓存数据永不过期, 3.提前预热(在系统上线前,提前将热点数据加载到缓存中) 等方案)
func (s *CacheKeyMutex) Get(key string) *sync.Mutex {
	return s.mutex[hey.MakeCacheQueryMutexIndex(key, s.capacity)]
}

// NewCacheKeyMutex 创建一个指定容量的缓存互斥锁集合
func NewCacheKeyMutex(capacity int) *CacheKeyMutex {
	if capacity <= 0 {
		capacity = 512
	}
	tmp := &CacheKeyMutex{
		capacity: capacity,
		mutex:    make(map[int]*sync.Mutex, capacity),
	}
	for i := 0; i < capacity; i++ {
		tmp.mutex[i] = &sync.Mutex{}
	}
	return tmp
}

var (
    // CacheMutex 默认缓存互斥锁集合
	CacheMutex = NewCacheKeyMutex(512)
)

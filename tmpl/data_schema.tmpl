// hey-template version: {{{.Version}}}
// TEMPLATE CODE DO NOT EDIT IT.

package data

import (
	"github.com/cd365/hey"

	"{{{.PrefixPackage}}}/model"
)

type schema struct {
	// insertIgnoreColumns 插入数据需要忽略的字段列表
	insertIgnoreColumns []string
	// updateIgnoreColumns 更新数据需要忽略的字段列表
	updateIgnoreColumns []string
	// selectIgnoreColumns 查询数据需要忽略的字段列表
	selectIgnoreColumns []string

	// insertPermitColumns 插入数据允许查询的字段列表
	insertPermitColumns []string
	// selectPermitColumns 查询数据允许查询的字段列表
	selectPermitColumns []string

	// deleteFilter 删除数据的前提条件(删除的数据必须满足当前方法返回的条件)
	deleteFilter hey.Filter
	// updateFilter 更新数据的前提条件(更新的数据必须满足当前方法返回的条件)
	updateFilter hey.Filter
	// selectFilter 查询数据的前提条件(查询的数据必须满足当前方法返回的条件)
	selectFilter hey.Filter

	// deleteForbidMsg 删除不允许删除的数据(提示语)
	deleteForbidMsg string
	// updateForbidMsg 更新不允许更新的数据(提示语)
	updateForbidMsg string
}

type Tables struct {
    tableMap map[string]model.Table
    tableSlice []string
	{{{.MapListDefine}}}
}

var (
	// ats 方便当前包内某个表的实例对象引用其它表实例,特别是在自定义方法中(all tables)
	ats *Tables
)

func NewTables(
	{{{.MapListParams}}}
) *Tables {
	tables := &Tables{
		{{{.MapListAssign}}}
	}
	tables.tableMap = map[string]model.Table{
        {{{.MapListStorage}}}
    }
    tables.tableSlice = []string{
        {{{.MapListSlice}}}
    }
    if ats == nil {
        ats = tables
    }
    return tables
}

func AutoWay(defaultWay *hey.Way, options ...*hey.Way) *hey.Way {
	for i := len(options) - 1; i >= 0; i-- {
		if options[i] != nil {
			return options[i]
		}
	}
	return defaultWay
}

func (s *Tables) MAP() map[string]model.Table {
	length := len(s.tableMap)
	result := make(map[string]model.Table, length)
	for k, v := range s.tableMap {
		result[k] = v
	}
	return result
}

func (s *Tables) SLICE() []string {
	length := len(s.tableSlice)
	result := make([]string, length)
	copy(result, s.tableSlice)
	return result
}

func (s *Tables) WRITER(table model.Table, way ...*hey.Way) Writer {
	return &writer{
		table: table,
		way:   AutoWay(table.Add().Way(), way...),
	}
}

type Writer interface {
	Add(i interface{}, prefix ...func(add *hey.Add)) (int64, error)
	AddMust(i interface{}, prefix ...func(add *hey.Add)) error
	Del(where hey.Filter) (int64, error)
	DelMust(where hey.Filter) error
	Mod(where hey.Filter, modify interface{}, prefix ...func(mod *hey.Mod)) (int64, error)
	ModMust(where hey.Filter, modify interface{}, prefix ...func(mod *hey.Mod)) error
}

type writer struct {
	table model.Table
	way   *hey.Way
}

func (s *writer) Add(i interface{}, prefix ...func(add *hey.Add)) (int64, error) {
	tmp := s.table.Add(s.way).Except(s.table.AddExcept()...)
	if length := len(prefix); length > 0 {
		prefix[length-1](tmp)
	}
	s.table.AddAt(tmp, s.way)
	return tmp.Create(i).Add()
}

func (s *writer) AddMust(i interface{}, prefix ...func(add *hey.Add)) error {
	return hey.MustAffectedRows(s.Add(i, prefix...))
}

func (s *writer) Del(where hey.Filter) (int64, error) {
	return s.table.Del(s.way).Where(where).Del()
}

func (s *writer) DelMust(where hey.Filter) error {
	return hey.MustAffectedRows(s.Del(where))
}

func (s *writer) Mod(where hey.Filter, modify interface{}, prefix ...func(mod *hey.Mod)) (int64, error) {
	tmp := s.table.Mod(s.way).Except(s.table.ModExcept()...)
	if length := len(prefix); length > 0 {
		prefix[length-1](tmp)
	}
	s.table.ModAt(tmp, s.way)
	return tmp.Where(where).Modify(modify).Mod()
}

func (s *writer) ModMust(where hey.Filter, modify interface{}, prefix ...func(mod *hey.Mod)) error {
	return hey.MustAffectedRows(s.Mod(where, modify, prefix...))
}

// MakeSliceMap 提取字段并构建哈希表和哈希表键值切片
func MakeSliceMap[T any, K comparable](slice []T, key func(v T) K) (keys []K, maps map[K]T) {
	for _, item := range slice {
		tmp := key(item)
		if _, ok := maps[tmp]; ok {
			continue
		}
		if maps == nil {
			keys = make([]K, 0, 32)
			maps = make(map[K]T, 32)
		}
		maps[tmp] = item
		keys = append(keys, tmp)
	}
	return keys, maps
}

// MatchAssign 匹配赋值
func MatchAssign[T any, U any, K comparable](maps map[K]T, slices []U, key func(U) K, assign func(T, U)) {
	for i := range slices {
		tmp := key(slices[i])
		if value, found := maps[tmp]; found {
			assign(value, slices[i])
		}
	}
}

// QueryAssign 查询数据并匹配赋值
func QueryAssign[T any, U any, K comparable](maps map[K]T, query func() ([]U, error), key func(v U) K, assign func(a T, b U)) error {
	slices, err := query()
	if err != nil {
		return err
	}
	for i := range slices {
		tmp := key(slices[i])
		if value, found := maps[tmp]; found {
			assign(value, slices[i])
		}
	}
	return nil
}
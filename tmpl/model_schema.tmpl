// hey-template version: {{{.Version}}}
// TEMPLATE CODE DO NOT EDIT IT.

package model

import (
    "database/sql"
	"github.com/cd365/hey/v2"
)

var (
    Way *hey.Way // data operation object, don't forget to assign it.
)

// AutoSelectWay Get the last non-empty element.
func AutoSelectWay(ways ...*hey.Way) *hey.Way {
	for i := len(ways) - 1; i >= 0; i-- {
		if ways[i] != nil {
			return ways[i]
		}
	}
	if Way != nil {
        return Way
    }
    panic("model.Way is nil")
}

// MapValues Get all the values of the map.
func MapValues[T interface{}, U comparable](m map[U]T) []T {
	slice := make([]T, 0, len(m))
	for _, v := range m {
		slice = append(slice, v)
	}
	return slice
}

// SliceToMap Slice to map.
func SliceToMap[T interface{}, U comparable](slice []T, key func(tmp T) U) map[U]T {
	length := len(slice)
	m := make(map[U]T, length)
	for i := 0; i < length; i++ {
		m[key(slice[i])] = slice[i]
	}
	return m
}

// ColumnValueIn Build column IN ( ... )
func ColumnValueIn[T any](column string, value func(tmp T) interface{}, slice []T) hey.Filter {
	filter := hey.F()
	inValues := make([]interface{}, 0, len(slice))
	for _, tmp := range slice {
		inValues = append(inValues, value(tmp))
	}
	return filter.In(column, inValues...)
}

// RowsExists Check whether the data exists according to the conditions.
func RowsExists(table string, column string, where hey.Filter, custom func(get *hey.Get), ways ...*hey.Way) (exists bool, err error) {
	get := AutoSelectWay(ways...).Get(table).Column(column).Where(where)
	if custom != nil {
		custom(get)
	}
	get.Limit(1)
	err = get.ScanAll(func(rows *sql.Rows) error {
		exists = rows.Next()
		return nil
	})
	return
}

// RowsCount Total number of statistics according to the conditions.
func RowsCount(table string, where hey.Filter, column ...string) (count int64, err error) {
	return AutoSelectWay().Get(table).Where(where).Count(column...)
}

type Table interface {
    Table() string
	Comment() string
	Column(except ...string) []string
	ColumnExist(column string) bool
	ColumnAutoIncr() []string
	ColumnCreatedAt() []string
	ColumnUpdatedAt() []string
	ColumnDeletedAt() []string

    Add(ways ...*hey.Way) *hey.Add
    Del(ways ...*hey.Way) *hey.Del
    Mod(ways ...*hey.Way) *hey.Mod
    Get(ways ...*hey.Way) *hey.Get
	Insert(create interface{}, ways ...*hey.Way) (int64, error)
    Delete(where hey.Filter, ways ...*hey.Way) (int64, error)
    Update(where hey.Filter, modify interface{}, ways ...*hey.Way) (int64, error)
    SelectCount(where hey.Filter, ways ...*hey.Way) (int64, error)
}

type AllTable struct {
    schemaMap map[string]Table
    schemaSlice []string
	{{{.MapListDefine}}}
}

func NewAllTable() *AllTable {
	tmp := &AllTable{
		{{{.MapListAssign}}}
	}
	tmp.schemaMap = map[string]Table{
        {{{.MapListStorage}}}
    }
    tmp.schemaSlice = []string{
        {{{.MapListSlice}}}
    }
    return tmp
}

func (s *AllTable) TableMap() map[string]Table {
	length := len(s.schemaMap)
	result := make(map[string]Table, length)
	for k, v := range s.schemaMap {
		result[k] = v
	}
	return result
}

func (s *AllTable) TableSlice() []string {
	length := len(s.schemaSlice)
	result := make([]string, length)
	_ = copy(result, s.schemaSlice)
	return result
}

func (s *AllTable) TableExists(table string) bool {
	_, ok := s.schemaMap[table]
	return ok
}

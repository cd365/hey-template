
// PrimaryKeyUpdate Update based on the primary key as a condition. primaryKey can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpdate(primaryKey PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
    if primaryKey == nil {
        return 0, nil
    }
    pk := primaryKey.PrimaryKey()
    if pk == nil {
        return 0, nil
    }
	return s.Update(func(f hey.Filter, u *hey.Mod) {
        f.Equal(s.{{{.PrimaryKeyUpper}}}, pk).Use(filter, s.Available())
        u.Modify(primaryKey)
    }, ways...)
}

// PrimaryKeyHidden Hidden based on the primary key as a condition. primaryKey can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyHidden(primaryKey PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
    if primaryKey == nil {
        return 0, nil
    }
    pk := primaryKey.PrimaryKey()
    if pk == nil {
        return 0, nil
    }
	updates := make(map[string]interface{}, 8)
	way := s.Way(ways...)
	now := way.Now()
	for _, tmp := range s.ColumnDeletedAt() {
		updates[tmp] = now.Unix()
	}
	if len(updates) == 0 {
		return 0, nil
	}
	return s.Update(func(f hey.Filter, u *hey.Mod) {
        f.Equal(s.{{{.PrimaryKeyUpper}}}, pk).Use(filter, s.Available())
        u.Modify(updates)
    }, ways...)
}

// PrimaryKeyDelete Delete based on the primary key as a condition. primaryKey can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyDelete(primaryKey PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
    if primaryKey == nil {
        return 0, nil
    }
    pk := primaryKey.PrimaryKey()
    if pk == nil {
        return 0, nil
    }
	return s.Delete(s.Filter(func(f hey.Filter, t *SCHEMA{{{.OriginNamePascal}}}) {
        f.Equal(t.{{{.PrimaryKeyUpper}}}, pk).Use(filter, s.Available())
    }), ways...)
}

// PrimaryKeyUpsert Upsert based on the primary key as a condition. primaryKey can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpsert(primaryKey PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	if primaryKey == nil {
		return 0, nil
	}
	pk := primaryKey.PrimaryKey()
	if pk == nil {
		return s.Add(ways...).Default(func(o *hey.Add) {
            timestamp := o.Way().Now().Unix()
            for _, v := range s.ColumnCreatedAt() {
                o.FieldValue(v, timestamp)
            }
        }).Create(primaryKey).ReturningId()
	}
	return s.PrimaryKeyUpdate(primaryKey, filter, ways...)
}

// PrimaryKeyUpdateAll Batch update based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpdateAll(ctx context.Context, way *hey.Way, pks ...PrimaryKey) (int64, error) {
	var total int64
	err := s.Way(way).TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range pks {
			if num, err := s.PrimaryKeyUpdate(tmp, nil, tx); err != nil {
				return err
			} else {
				total += num
			}
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

// PrimaryKeyHiddenAll Batch hidden based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyHiddenAll(ctx context.Context, way *hey.Way, pks ...PrimaryKey) (int64, error) {
	var total int64
	err := s.Way(way).TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range pks {
			if num, err := s.PrimaryKeyHidden(tmp, nil, tx); err != nil {
				return err
			} else {
				total += num
			}
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

// PrimaryKeyDeleteAll Batch delete based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyDeleteAll(ctx context.Context, way *hey.Way, pks ...PrimaryKey) (int64, error) {
	var total int64
	err := s.Way(way).TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range pks {
			if num, err := s.PrimaryKeyDelete(tmp, nil, tx); err != nil {
				return err
			} else {
				total += num
			}
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

// PrimaryKeyUpsertAll Batch upsert based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpsertAll(ctx context.Context, way *hey.Way, pks ...PrimaryKey) (int64, error) {
	var total int64
	var err error
    var num int64
	err = s.Way(way).TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range pks {
			if tmp == nil {
                continue
            }
            pk := tmp.PrimaryKey()
            if pk == nil {
                num, err = s.Add(tx).Default(func(o *hey.Add) {
                    timestamp := o.Way().Now().Unix()
                    for _, v := range s.ColumnCreatedAt() {
                        o.FieldValue(v, timestamp)
                    }
                }).Create(tmp).Add()
            } else {
                num, err = s.PrimaryKeyUpdate(tmp, nil, tx)
            }
            if err != nil {
                return err
            } else {
                total += num
            }
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyEqual(value interface{}) hey.Filter {
	return hey.F().Equal(s.{{{.PrimaryKeyUpper}}}, value)
}

func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyIn(values ...interface{}) hey.Filter {
	return hey.F().In(s.{{{.PrimaryKeyUpper}}}, values...)
}

func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpdateMap(primaryKey interface{}, modify map[string]interface{}, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	if primaryKey == nil || len(modify) == 0 {
		return 0, nil
	}
	return s.Update(func(f hey.Filter, u *hey.Mod) {
		f.Use(s.PrimaryKeyEqual(primaryKey), filter, s.Available())
		u.Modify(modify)
	}, ways...)
}

func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpsertMap(primaryKey interface{}, upsert map[string]interface{}, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	if len(upsert) == 0 {
		return 0, nil
	}
	if primaryKey == nil {
		return s.Insert(upsert, ways...)
	}
	where := s.PrimaryKeyEqual(primaryKey).Use(filter, s.Available())
	exists, err := s.SelectExists(where, func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) { get.Column(t.{{{.PrimaryKeyUpper}}}) }, ways...)
	if err != nil {
		return 0, err
	}
	if !exists {
		return s.Insert(upsert, ways...)
	}
	return s.Update(func(f hey.Filter, u *hey.Mod) {
		f.Use(where)
		u.Modify(upsert)
	}, ways...)
}

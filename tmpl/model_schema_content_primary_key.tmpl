
// PrimaryKeyUpdate Update based on the primary key as a condition. primaryKey can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpdate(primaryKey PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
    if primaryKey == nil {
        return 0, nil
    }
    pk := primaryKey.PrimaryKey()
    if pk == nil {
        return 0, nil
    }
	return s.Update(func(f hey.Filter, u *hey.Mod) {
        f.Equal(s.{{{.PrimaryKeyUpper}}}, pk).Use(filter)
        u.Modify(primaryKey)
    }, ways...)
}

// PrimaryKeyHidden Hidden based on the primary key as a condition. primaryKey can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyHidden(primaryKey PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
    if primaryKey == nil {
        return 0, nil
    }
    pk := primaryKey.PrimaryKey()
    if pk == nil {
        return 0, nil
    }
	updates := make(map[string]interface{}, 8)
	way := s.Way(ways...)
	now := way.Now()
	for _, tmp := range s.ColumnDeletedAt() {
		updates[tmp] = now.Unix()
	}
	if len(updates) == 0 {
		return 0, nil
	}
	return s.Update(func(f hey.Filter, u *hey.Mod) {
        f.Equal(s.{{{.PrimaryKeyUpper}}}, pk).Use(filter)
        u.Modify(updates)
    }, ways...)
}

// PrimaryKeyDelete Delete based on the primary key as a condition. primaryKey can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyDelete(primaryKey PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
    if primaryKey == nil {
        return 0, nil
    }
    pk := primaryKey.PrimaryKey()
    if pk == nil {
        return 0, nil
    }
	return s.Delete(s.Filter(func(f hey.Filter, t *SCHEMA{{{.OriginNamePascal}}}) {
        f.Equal(t.{{{.PrimaryKeyUpper}}}, pk).Use(filter)
    }), ways...)
}

// PrimaryKeyUpsert Upsert based on the primary key as a condition. primaryKey can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpsert(primaryKey PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	if primaryKey == nil {
		return 0, nil
	}
	pk := primaryKey.PrimaryKey()
	if pk == nil {
		return s.Add(ways...).Default(func(o *hey.Add) {
            timestamp := o.Way().Now().Unix()
            for _, v := range s.ColumnCreatedAt() {
                o.FieldValue(v, timestamp)
            }
        }).Create(primaryKey).ReturningId()
	}
	return s.PrimaryKeyUpdate(primaryKey, filter, ways...)
}

// PrimaryKeyUpdateAll Batch update based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpdateAll(ctx context.Context, way *hey.Way, pks ...PrimaryKey) (int64, error) {
	var total int64
	err := s.Way(way).TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range pks {
			if num, err := s.PrimaryKeyUpdate(tmp, nil, tx); err != nil {
				return err
			} else {
				total += num
			}
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

// PrimaryKeyHiddenAll Batch hidden based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyHiddenAll(ctx context.Context, way *hey.Way, pks ...PrimaryKey) (int64, error) {
	var total int64
	err := s.Way(way).TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range pks {
			if num, err := s.PrimaryKeyHidden(tmp, nil, tx); err != nil {
				return err
			} else {
				total += num
			}
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

// PrimaryKeyDeleteAll Batch delete based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyDeleteAll(ctx context.Context, way *hey.Way, pks ...PrimaryKey) (int64, error) {
	var total int64
	err := s.Way(way).TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range pks {
			if num, err := s.PrimaryKeyDelete(tmp, nil, tx); err != nil {
				return err
			} else {
				total += num
			}
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

// PrimaryKeyUpsertAll Batch upsert based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpsertAll(ctx context.Context, way *hey.Way, pks ...PrimaryKey) (int64, error) {
	var total int64
	var err error
    var num int64
	err = s.Way(way).TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range pks {
			if tmp == nil {
                continue
            }
            pk := tmp.PrimaryKey()
            if pk == nil {
                num, err = s.Add(tx).Default(func(o *hey.Add) {
                    timestamp := o.Way().Now().Unix()
                    for _, v := range s.ColumnCreatedAt() {
                        o.FieldValue(v, timestamp)
                    }
                }).Create(tmp).Add()
            } else {
                num, err = s.PrimaryKeyUpdate(tmp, nil, tx)
            }
            if err != nil {
                return err
            } else {
                total += num
            }
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

// PrimaryKeyEqual Build Filter PrimaryKey = value
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyEqual(value interface{}) hey.Filter {
	return hey.F().Equal(s.{{{.PrimaryKeyUpper}}}, value)
}

// PrimaryKeyIn Build Filter PrimaryKey IN ( values... )
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyIn(values ...interface{}) hey.Filter {
	return hey.F().In(s.{{{.PrimaryKeyUpper}}}, values...)
}

// PrimaryKeyUpdateMap Update a row of data using map[string]interface{} by primary key value. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpdateMap(primaryKey interface{}, modify map[string]interface{}, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	if primaryKey == nil || len(modify) == 0 {
		return 0, nil
	}
	return s.Update(func(f hey.Filter, u *hey.Mod) {
		f.Use(s.PrimaryKeyEqual(primaryKey), filter)
		u.Modify(modify)
	}, ways...)
}

// PrimaryKeyUpsertMap Upsert a row of data using map[string]interface{} by primary key value. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpsertMap(primaryKey interface{}, upsert map[string]interface{}, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	if len(upsert) == 0 {
		return 0, nil
	}
	if primaryKey == nil {
		return s.Insert(upsert, ways...)
	}
	where := s.PrimaryKeyEqual(primaryKey)
	exists, err := s.SelectExists(s.Filter().Use(where, filter, s.Available()), func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) { get.Column(t.{{{.PrimaryKeyUpper}}}) }, ways...)
	if err != nil {
		return 0, err
	}
	if !exists {
		return s.Insert(upsert, ways...)
	}
	return s.Update(func(f hey.Filter, u *hey.Mod) {
		f.Use(where, filter)
		u.Modify(upsert)
	}, ways...)
}

// PrimaryKeyDeleteFilter Delete one or more records based on the primary key values. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyDeleteFilter(primaryKeys interface{}, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	return s.Delete(s.PrimaryKeyIn(primaryKeys).Use(filter), ways...)
}

// PrimaryKeySelectAll Query multiple records based on primary key values. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeySelectAll(primaryKeys interface{}, custom func(get *hey.Get), filter hey.Filter, ways ...*hey.Way) ([]*{{{.OriginNamePascal}}}, error) {
	return s.SelectAll(s.PrimaryKeyIn(primaryKeys).Use(filter, s.Available()), func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) {
		if custom != nil {
			custom(get)
		}
	}, ways...)
}

// PrimaryKeySelectOne Query a piece of data based on the primary key value. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeySelectOne(primaryKey interface{}, custom func(get *hey.Get), filter hey.Filter, ways ...*hey.Way) (*{{{.OriginNamePascal}}}, error) {
	return s.SelectOne(s.PrimaryKeyEqual(primaryKey).Use(filter, s.Available()), func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) {
		if custom != nil {
			custom(get)
		}
	}, ways...)
}

// PrimaryKeySelectExists Check whether the data exists based on the primary key value. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeySelectExists(primaryKey interface{}, filter hey.Filter, ways ...*hey.Way) (bool, error) {
	if primaryKey == nil {
		return false, nil
	}
	return s.SelectExists(s.PrimaryKeyEqual(primaryKey).Use(filter, s.Available()), func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) { get.Column(t.{{{.PrimaryKeyUpper}}}) }, ways...)
}

// PrimaryKeySelectCount The number of statistics based on primary key values. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeySelectCount(primaryKeys interface{}, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	if primaryKeys == nil {
		return 0, nil
	}
	return s.SelectCount(s.PrimaryKeyIn(primaryKeys).Use(filter, s.Available()), ways...)
}

{{{/* Generate different types of map structures according to the primary key value type, including string, int, int64. */}}}
{{{ if ne .PrimaryKeyType "" }}}
    {{{ if eq .PrimaryKeyType "string" }}}
// PrimaryKeySelectAllMap Make map[string]*{{{.OriginNamePascal}}} and []*{{{.OriginNamePascal}}}
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeySelectAllMap(primaryKeys interface{}, custom func(get *hey.Get), filter hey.Filter, ways ...*hey.Way) (map[{{{.PrimaryKeyType}}}]*{{{.OriginNamePascal}}}, []*{{{.OriginNamePascal}}}, error) {
    return s.SelectAllMap(s.PrimaryKeyIn(primaryKeys).Use(filter, s.Available()), func(v *{{{.OriginNamePascal}}}) {{{.PrimaryKeyType}}} { return v.{{{.PrimaryKeyPascal}}} }, func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) {
        if custom != nil {
            custom(get)
        }
    }, ways...)
}
    {{{ end }}}

    {{{ if eq .PrimaryKeyType "int" }}}
// PrimaryKeySelectAllMap Make map[int]*{{{.OriginNamePascal}}} and []*{{{.OriginNamePascal}}}
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeySelectAllMap(primaryKeys interface{}, custom func(get *hey.Get), filter hey.Filter, ways ...*hey.Way) (map[{{{.PrimaryKeyType}}}]*{{{.OriginNamePascal}}}, []*{{{.OriginNamePascal}}}, error) {
	return s.SelectAllMapInt(s.PrimaryKeyIn(primaryKeys).Use(filter, s.Available()), func(v *{{{.OriginNamePascal}}}) {{{.PrimaryKeyType}}} { return v.{{{.PrimaryKeyPascal}}} }, func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) {
        if custom != nil {
            custom(get)
        }
    }, ways...)
}
    {{{ end }}}

    {{{ if eq .PrimaryKeyType "int64" }}}
// PrimaryKeySelectAllMap Make map[int64]*{{{.OriginNamePascal}}} and []*{{{.OriginNamePascal}}}
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeySelectAllMap(primaryKeys interface{}, custom func(get *hey.Get), filter hey.Filter, ways ...*hey.Way) (map[{{{.PrimaryKeyType}}}]*{{{.OriginNamePascal}}}, []*{{{.OriginNamePascal}}}, error) {
    return s.SelectAllMapInt64(s.PrimaryKeyIn(primaryKeys).Use(filter, s.Available()), func(v *{{{.OriginNamePascal}}}) {{{.PrimaryKeyType}}} { return v.{{{.PrimaryKeyPascal}}} }, func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) {
        if custom != nil {
            custom(get)
        }
    }, ways...)
}
    {{{ end }}}
{{{ end }}}

// PrimaryKeyGetAll Query multiple records based on primary key values.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyGetAll(primaryKeys interface{}, ways ...*hey.Way) ([]*{{{.OriginNamePascal}}}, error) {
	return s.PrimaryKeySelectAll(primaryKeys, nil, nil, ways...)
}

// PrimaryKeyGetOne Query a piece of data based on the primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyGetOne(primaryKey interface{}, ways ...*hey.Way) (*{{{.OriginNamePascal}}}, error) {
	return s.PrimaryKeySelectOne(primaryKey, nil, nil, ways...)
}

// PrimaryKeyGetAllMap Make map[{{{.PrimaryKeyType}}}]*{{{.OriginNamePascal}}} and []*{{{.OriginNamePascal}}}
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyGetAllMap(primaryKeys interface{}, ways ...*hey.Way) (map[{{{.PrimaryKeyType}}}]*{{{.OriginNamePascal}}}, []*{{{.OriginNamePascal}}}, error) {
	return s.PrimaryKeySelectAllMap(primaryKeys, nil, nil, ways...)
}

// PrimaryKeyExists Check whether the data exists based on the primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyExists(primaryKey interface{}, ways ...*hey.Way) (bool, error) {
	return s.PrimaryKeySelectExists(primaryKey, nil, ways...)
}

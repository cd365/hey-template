
// PrimaryKeyUpdate Update based on the primary key as a condition. update can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpdate(update PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
    if update == nil {
        return 0, nil
    }
    pk := update.PrimaryKey()
    if pk == nil {
        return 0, nil
    }
	return s.Update(func(f hey.Filter, u *hey.Mod) {
        f.Equal(s.{{{.PrimaryKeyUpper}}}, pk).Use(filter, s.Available())
        u.Modify(update)
    }, ways...)
}

// PrimaryKeyHidden Hidden based on the primary key as a condition. hidden can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyHidden(hidden PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
    if hidden == nil {
        return 0, nil
    }
    pk := hidden.PrimaryKey()
    if pk == nil {
        return 0, nil
    }
	updates := make(map[string]interface{}, 8)
	way := s.Way(ways...)
	now := way.Now()
	for _, tmp := range s.ColumnDeletedAt() {
		updates[tmp] = now.Unix()
	}
	if len(updates) == 0 {
		return 0, nil
	}
	return s.Update(func(f hey.Filter, u *hey.Mod) {
        f.Equal(s.{{{.PrimaryKeyUpper}}}, pk).Use(filter, s.Available())
        u.Modify(updates)
    }, ways...)
}

// PrimaryKeyDelete Delete based on the primary key as a condition. remove can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyDelete(remove PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
    if remove == nil {
        return 0, nil
    }
    pk := remove.PrimaryKey()
    if pk == nil {
        return 0, nil
    }
	return s.Delete(s.Filter(func(f hey.Filter, t *SCHEMA{{{.OriginNamePascal}}}) {
        f.Equal(t.{{{.PrimaryKeyUpper}}}, pk).Use(filter, s.Available())
    }), ways...)
}

// PrimaryKeySaving Saving based on the primary key as a condition. saving can be any struct or struct pointer that implements the PrimaryKey interface. Additional conditions can be added in the filter.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeySaving(saving PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	if saving == nil {
		return 0, nil
	}
	pk := saving.PrimaryKey()
	if pk == nil {
		return s.Add(ways...).Default(func(o *hey.Add) {
            timestamp := o.Way().Now().Unix()
            for _, v := range s.ColumnCreatedAt() {
                o.FieldValue(v, timestamp)
            }
        }).Create(saving).ReturningId()
	}
	return s.PrimaryKeyUpdate(saving, filter, ways...)
}

// PrimaryKeyUpdateAll Batch update based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyUpdateAll(ctx context.Context, updateLists []PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	way := s.Way(ways...)
	var total int64
	err := way.TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range updateLists {
			if num, err := s.PrimaryKeyUpdate(tmp, filter, tx); err != nil {
				return err
			} else {
				total += num
			}
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

// PrimaryKeyHiddenAll Batch hidden based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyHiddenAll(ctx context.Context, hiddenLists []PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	way := s.Way(ways...)
	var total int64
	err := way.TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range hiddenLists {
			if num, err := s.PrimaryKeyHidden(tmp, filter, tx); err != nil {
				return err
			} else {
				total += num
			}
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

// PrimaryKeyDeleteAll Batch delete based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyDeleteAll(ctx context.Context, deleteLists []PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	way := s.Way(ways...)
	var total int64
	err := way.TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range deleteLists {
			if num, err := s.PrimaryKeyDelete(tmp, filter, tx); err != nil {
				return err
			} else {
				total += num
			}
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

// PrimaryKeySavingAll Batch saving based on primary key value.
func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeySavingAll(ctx context.Context, savingLists []PrimaryKey, filter hey.Filter, ways ...*hey.Way) (int64, error) {
	way := s.Way(ways...)
	var total int64
	var err error
    var num int64
	err = way.TransactionContext(ctx, 1, func(tx *hey.Way) error {
		for _, tmp := range savingLists {
			if tmp == nil {
                continue
            }
            pk := tmp.PrimaryKey()
            if pk == nil {
                num, err = s.Add(ways...).Default(func(o *hey.Add) {
                    timestamp := o.Way().Now().Unix()
                    for _, v := range s.ColumnCreatedAt() {
                        o.FieldValue(v, timestamp)
                    }
                }).Create(tmp).Add()
            } else {
                num, err = s.PrimaryKeyUpdate(tmp, filter, tx)
            }
            if err != nil {
                return err
            } else {
                total += num
            }
		}
		return nil
	}, nil)
	if err != nil {
		return 0, err
	}
	return total, nil
}

func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyEqual(value interface{}) hey.Filter {
	return hey.F().Equal(s.{{{.PrimaryKeyUpper}}}, value)
}

func (s *SCHEMA{{{.OriginNamePascal}}}) PrimaryKeyIn(values ...interface{}) hey.Filter {
	return hey.F().In(s.{{{.PrimaryKeyUpper}}}, values...)
}

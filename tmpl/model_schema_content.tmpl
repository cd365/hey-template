// hey-template version: {{{.Version}}}
// TEMPLATE CODE DO NOT EDIT IT.

package model

import (
    "context"
    "database/sql"
	"github.com/cd365/hey/v2"
)

// {{{.OriginNamePascal}}} | {{{.OriginName}}} {{{if ne .Comment ""}}}| {{{.Comment}}}{{{end}}}
type {{{.OriginNamePascal}}} struct {
{{{range $k, $v := .StructColumn}}}{{{$v}}}{{{end}}}
}

type SCHEMA{{{.OriginNamePascal}}} struct {
{{{range $k, $v := .StructColumnSchema}}}{{{$v}}}{{{end}}}
    columnMap map[string]*struct{}
    columnSlice []string
    way *hey.Way
}

func (s *SCHEMA{{{.OriginNamePascal}}}) Table() string {
	return "{{{.OriginNameWithPrefix}}}"
}

func (s *SCHEMA{{{.OriginNamePascal}}}) Comment() string {
	return "{{{.Comment}}}"
}

func (s *SCHEMA{{{.OriginNamePascal}}}) Column(except ...string) []string {
	excepted := make(map[string]*struct{})
    for _, v := range except {
        excepted[v] = &struct{}{}
    }
    result := make([]string, 0, len(s.columnSlice))
    for _, v := range s.columnSlice {
        if _, ok := excepted[v]; ok {
            continue
        }
        result = append(result, v)
    }
    return result
}

func (s *SCHEMA{{{.OriginNamePascal}}}) ColumnMap() map[string]*struct{} {
	result := make(map[string]*struct{}, len(s.columnMap))
	for k, v := range s.columnMap {
		result[k] = v
	}
	return result
}

func (s *SCHEMA{{{.OriginNamePascal}}}) ColumnString() string {
	return {{{.StructColumnSchemaFieldSliceValue}}}
}

func (s *SCHEMA{{{.OriginNamePascal}}}) ColumnExist(column string) bool {
	_, exist := s.columnMap[column]
	return exist
}

func (s *SCHEMA{{{.OriginNamePascal}}}) ColumnAutoIncr() []string {
	return {{{.ColumnAutoIncr}}}
}

func (s *SCHEMA{{{.OriginNamePascal}}}) ColumnCreatedAt() []string {
	return {{{.ColumnCreatedAt}}}
}

func (s *SCHEMA{{{.OriginNamePascal}}}) ColumnUpdatedAt() []string {
	return {{{.ColumnUpdatedAt}}}
}

func (s *SCHEMA{{{.OriginNamePascal}}}) ColumnDeletedAt() []string {
	return {{{.ColumnDeletedAt}}}
}

func (s *SCHEMA{{{.OriginNamePascal}}}) Filter(filters ...func(f hey.Filter, t *SCHEMA{{{.OriginNamePascal}}})) hey.Filter {
	filter := s.way.F()
	for _, tmp := range filters {
		if tmp != nil {
			tmp(filter, s)
		}
	}
	return filter
}

func (s *SCHEMA{{{.OriginNamePascal}}}) Add(ways ...*hey.Way) *hey.Add {
	except := s.ColumnAutoIncr()
	return AutoSelectWay(s.way, ways...).Add(s.Table()).Except(except...).Permit(s.Column(except...)...)
}

func (s *SCHEMA{{{.OriginNamePascal}}}) Del(ways ...*hey.Way) *hey.Del {
	return AutoSelectWay(s.way, ways...).Del(s.Table())
}

func (s *SCHEMA{{{.OriginNamePascal}}}) Mod(ways ...*hey.Way) *hey.Mod {
	except := s.ColumnAutoIncr()
	except = append(except, s.ColumnCreatedAt()...)
	return AutoSelectWay(s.way, ways...).Mod(s.Table()).Except(except...).Permit(s.Column(except...)...)
}

func (s *SCHEMA{{{.OriginNamePascal}}}) Get(ways ...*hey.Way) *hey.Get {
	return AutoSelectWay(s.way, ways...).Get(s.Table()).Column(s.Column()...)
}

func (s *SCHEMA{{{.OriginNamePascal}}}) Way(ways ...*hey.Way) *hey.Way {
	return AutoSelectWay(s.way, ways...)
}

func (s *SCHEMA{{{.OriginNamePascal}}}) Available() hey.Filter {
	return s.Filter(func(f hey.Filter, t *SCHEMA{{{.OriginNamePascal}}}) {
		for _, v := range s.ColumnDeletedAt() {
			f.Equal(v, 0)
		}
	})
}

// Insert SQL INSERT.
func (s *SCHEMA{{{.OriginNamePascal}}}) Insert(create interface{}, ways ...*hey.Way) (int64, error) {
	ctx, cancel := context.WithTimeout(Context, DoSqlTimeout)
	defer cancel()
	return s.Add(ways...).
		Context(ctx).
		Default(func(o *hey.Add) {
			timestamp := o.Way().Now().Unix()
			for _, v := range s.ColumnCreatedAt() {
				o.FieldValue(v, timestamp)
			}
		}).
		Create(create).
		Add()
}

// Delete SQL DELETE.
func (s *SCHEMA{{{.OriginNamePascal}}}) Delete(where hey.Filter, ways ...*hey.Way) (int64, error) {
	if where.IsEmpty() {
		return 0, nil
	}
	ctx, cancel := context.WithTimeout(Context, DoSqlTimeout)
	defer cancel()
	return s.Del(ways...).
		Context(ctx).
		Where(where.Use(s.Available())).
		Del()
}

// Update SQL UPDATE.
func (s *SCHEMA{{{.OriginNamePascal}}}) Update(update func(f hey.Filter, u *hey.Mod), ways ...*hey.Way) (int64, error) {
	modify := s.Mod(ways...).
		Default(func(o *hey.Mod) {
			timestamp := o.Way().Now().Unix()
			for _, v := range s.ColumnUpdatedAt() {
				o.Set(v, timestamp)
			}
		})
	filter := s.Filter()
	if update != nil {
		update(filter, modify)
	}
	if filter.IsEmpty() {
		return 0, nil
	}
	ctx, cancel := context.WithTimeout(Context, DoSqlTimeout)
	defer cancel()
	return modify.Context(ctx).Where(filter.Use(s.Available())).Mod()
}

// InsertOne Insert a record and return the auto-increment id.
func (s *SCHEMA{{{.OriginNamePascal}}}) InsertOne(create interface{}, ways ...*hey.Way) (int64, error) {
	return s.Add(ways...).Default(func(o *hey.Add) {
		timestamp := o.Way().Now().Unix()
		for _, v := range s.ColumnCreatedAt() {
			o.FieldValue(v, timestamp)
		}
	}).Create(create).ReturningId()
}

// InsertSelect SQL INSERT SELECT.
func (s *SCHEMA{{{.OriginNamePascal}}}) InsertSelect(column []string, get *hey.Get, ways ...*hey.Way) (int64, error) {
	ctx, cancel := context.WithTimeout(Context, DoSqlTimeout)
	defer cancel()
	return s.Add(ways...).Context(ctx).ValuesSubQueryGet(get, column...).Add()
}

// SelectCount SQL SELECT COUNT.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectCount(where hey.Filter, ways ...*hey.Way) (int64, error) {
	return s.Get(ways...).Where(where).Count()
}

// SelectQuery SQL SELECT.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectQuery(where hey.Filter, custom func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}), query func(rows *sql.Rows) error, ways ...*hey.Way) error {
	get := s.Get(ways...).Where(where)
	if custom != nil {
		custom(get, s)
	}
	return get.Query(query)
}

// EmptySlice Initialize an empty slice.
func (s *SCHEMA{{{.OriginNamePascal}}}) EmptySlice() []*{{{.OriginNamePascal}}} {
	return make([]*{{{.OriginNamePascal}}}, 0, 32)
}

// SelectGet SQL SELECT.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectGet(where hey.Filter, custom func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}), receive interface{}, ways ...*hey.Way) error {
	get := s.Get(ways...).Where(where)
	if custom != nil {
		custom(get, s)
	}
	return get.Get(receive)
}

// SelectAll SQL SELECT ALL.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectAll(where hey.Filter, custom func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}), ways ...*hey.Way) ([]*{{{.OriginNamePascal}}}, error) {
	get := s.Get(ways...).Where(where)
	if custom != nil {
		custom(get, s)
	}
	all := s.EmptySlice()
	err := get.Get(&all)
	if err != nil {
		return nil, err
	}
	return all, nil
}

// SelectOne SQL SELECT ONE.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectOne(where hey.Filter, custom func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}), ways ...*hey.Way) (*{{{.OriginNamePascal}}}, error) {
	all, err := s.SelectAll(where, func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) {
		if custom != nil {
			custom(get, t)
		}
		get.Limit(1)
	}, ways...)
	if err != nil {
		return nil, err
	}
	if len(all) == 0 {
		return nil, nil
	}
	return all[0], nil
}

// SelectExists SQL SELECT EXISTS.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectExists(where hey.Filter, custom func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}), ways ...*hey.Way) (bool, error) {
	exists, err := s.SelectOne(where, func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) {
		if custom != nil {
			custom(get, t)
		}
		get.Column(s.Column()[0])
	}, ways...)
	if err != nil {
		return false, err
	}
	return exists != nil, nil
}

// SelectCountAll SQL SELECT COUNT + ALL.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectCountAll(where hey.Filter, custom func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}), ways ...*hey.Way) (int64, []*{{{.OriginNamePascal}}}, error) {
	total, err := s.SelectCount(where, ways...)
	if err != nil {
		return 0, nil, err
	}
	if total == 0 {
		return 0, make([]*{{{.OriginNamePascal}}}, 0), nil
	}
	all, err := s.SelectAll(where, custom, ways...)
	if err != nil {
		return 0, nil, err
	}
	return total, all, nil
}

// SelectCountGet SQL SELECT COUNT + GET.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectCountGet(where hey.Filter, custom func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}), receive interface{}, ways ...*hey.Way) (int64, error) {
	count, err := s.SelectCount(where, ways...)
	if err != nil {
		return 0, err
	}
	if count <= 0 {
		return 0, nil
	}
	if err = s.SelectGet(where, custom, receive, ways...); err != nil {
		return 0, err
	}
	return count, nil
}

// SelectAllMap Make map[string]*{{{.OriginNamePascal}}}
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectAllMap(where hey.Filter, makeMapKey func(v *{{{.OriginNamePascal}}}) string, custom func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}), ways ...*hey.Way) (map[string]*{{{.OriginNamePascal}}}, []*{{{.OriginNamePascal}}}, error) {
	all, err := s.SelectAll(where, custom, ways...)
	if err != nil {
		return nil, nil, err
	}
	allMap := make(map[string]*{{{.OriginNamePascal}}}, len(all))
	for _, v := range all {
		allMap[makeMapKey(v)] = v
	}
	return allMap, all, nil
}

// SelectAllMapInt Make map[int]*{{{.OriginNamePascal}}}
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectAllMapInt(where hey.Filter, makeMapKey func(v *{{{.OriginNamePascal}}}) int, custom func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}), ways ...*hey.Way) (map[int]*{{{.OriginNamePascal}}}, []*{{{.OriginNamePascal}}}, error) {
	all, err := s.SelectAll(where, custom, ways...)
	if err != nil {
		return nil, nil, err
	}
	allMap := make(map[int]*{{{.OriginNamePascal}}}, len(all))
	for _, v := range all {
		allMap[makeMapKey(v)] = v
	}
	return allMap, all, nil
}

// SelectAllMapInt64 Make map[int64]*{{{.OriginNamePascal}}}
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectAllMapInt64(where hey.Filter, makeMapKey func(v *{{{.OriginNamePascal}}}) int64, custom func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}), ways ...*hey.Way) (map[int64]*{{{.OriginNamePascal}}}, []*{{{.OriginNamePascal}}}, error) {
	all, err := s.SelectAll(where, custom, ways...)
	if err != nil {
		return nil, nil, err
	}
	allMap := make(map[int64]*{{{.OriginNamePascal}}}, len(all))
	for _, v := range all {
		allMap[makeMapKey(v)] = v
	}
	return allMap, all, nil
}

// DeleteByColumn Delete by column values. Additional conditions can be added in the filters. no transaction support.
func (s *SCHEMA{{{.OriginNamePascal}}}) DeleteByColumn(column string, values interface{}, filters ...hey.Filter) (int64, error) {
	return s.Delete(s.Filter().In(column, values).Use(filters...))
}

// UpdateByColumn Update by column values. Additional conditions can be added in the filters. no transaction support.
func (s *SCHEMA{{{.OriginNamePascal}}}) UpdateByColumn(column string, values interface{}, modify interface{}, filters ...hey.Filter) (int64, error) {
	if modify == nil {
		return 0, nil
	}
	return s.Update(func(f hey.Filter, u *hey.Mod) {
		f.In(column, values).Use(filters...)
		u.Modify(modify)
	})
}

// SelectAllByColumn Select all by column values. no transaction support.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectAllByColumn(column string, values interface{}, customs ...func(f hey.Filter, g *hey.Get, t *SCHEMA{{{.OriginNamePascal}}})) ([]*{{{.OriginNamePascal}}}, error) {
	where := s.Filter().In(column, values)
	return s.SelectAll(where, func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) {
		for _, custom := range customs {
			if custom != nil {
				custom(where, get, t)
				break
			}
		}
	})
}

// SelectOneByColumn Select one by column values. no transaction support.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectOneByColumn(column string, values interface{}, customs ...func(f hey.Filter, g *hey.Get, t *SCHEMA{{{.OriginNamePascal}}})) (*{{{.OriginNamePascal}}}, error) {
	where := s.Filter().In(column, values)
	return s.SelectOne(where, func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) {
		for _, custom := range customs {
			if custom != nil {
				custom(where, get, t)
				break
			}
		}
	})
}

// SelectExistsByColumn Select exists by column values. no transaction support.
func (s *SCHEMA{{{.OriginNamePascal}}}) SelectExistsByColumn(column string, values interface{}, customs ...func(f hey.Filter, g *hey.Get, t *SCHEMA{{{.OriginNamePascal}}})) (bool, error) {
	where := s.Filter().In(column, values)
	return s.SelectExists(where, func(get *hey.Get, t *SCHEMA{{{.OriginNamePascal}}}) {
		for _, custom := range customs {
			if custom != nil {
				custom(where, get, t)
				break
			}
		}
	})
}

func NewSCHEMA{{{.OriginNamePascal}}}(way *hey.Way) *SCHEMA{{{.OriginNamePascal}}} {
	s := &SCHEMA{{{.OriginNamePascal}}}{
{{{range $k, $v := .StructColumnSchemaValues}}}{{{$v}}}{{{end}}}
	}
	s.columnMap = {{{.StructColumnSchemaValuesAccessMap}}}
	s.columnSlice = {{{.StructColumnSchemaValuesAccess}}}
	s.way = way
	return s
}

type INSERT{{{.OriginNamePascal}}} struct {
{{{range $k, $v := .StructColumnAdd}}}{{{$v}}}{{{end}}}
}

{{{ .StructColumnAddPrimaryKey }}}

{{{ .StructColumnPrimaryKey }}}

type UPDATE{{{.OriginNamePascal}}} struct {
{{{range $k, $v := .StructColumnMod}}}{{{$v}}}{{{end}}}
}

{{{.PrimaryKey}}}

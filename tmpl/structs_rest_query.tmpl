package rest

import (
	"encoding/hex"
	"errors"
	"fmt"
	"net/http"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/cd365/hey"
	"github.com/go-playground/locales/zh"
	ut "github.com/go-playground/universal-translator"
	"github.com/go-playground/validator/v10"
	tzh "github.com/go-playground/validator/v10/translations/zh"
	"github.com/labstack/echo/v4"
)

// OfField 查询字段列表
type OfField struct {
	Field *string `json:"field" query:"field" form:"field" validate:"omitempty,min=1,max=1000"` // 查询字段列表(多个字段使用","分割)
}

// OfWhere 检索条件过滤
type OfWhere struct {
	Filter *string `json:"filter" query:"filter" form:"filter" validate:"omitempty,min=1,max=8192"` // 条件过滤
}

// filterRegexp 列名:[数据类型]条件类型:[条件值]
// 条件值存在多个使用","分割
var filterRegexp = regexp.MustCompile(`^([a-zA-Z][a-zA-Z0-9_]*):([idb]?)([ABC0123456789DEF]{2}):(.*)$`)

func parseInteger(str string) ([]interface{}, error) {
	splits := strings.Split(str, ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		i64, err := strconv.ParseInt(splits[i], 10, 64)
		if err != nil {
			return nil, err
		}
		result = append(result, i64)
	}
	return result, nil
}

func parseDouble(str string) ([]interface{}, error) {
	splits := strings.Split(str, ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		f64, err := strconv.ParseFloat(splits[i], 64)
		if err != nil {
			return nil, err
		}
		result = append(result, f64)
	}
	return result, nil
}

func parseBool(str string) ([]interface{}, error) {
	splits := strings.Split(str, ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		bol, err := strconv.ParseBool(splits[i])
		if err != nil {
			return nil, err
		}
		result = append(result, bol)
	}
	return result, nil
}

func parseString(str string) []interface{} {
	splits := strings.Split(str, ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		result = append(result, splits[i])
	}
	return result
}

// GetWhere 解析检索条件 ---> 使用","切割多个被 hex.EncodeToString([]byte(v)) 的字符串, v是满足 filterRegexp 正则表达式的条件字符串
func (s OfWhere) GetWhere(fieldMap ...map[string]string) (hey.Filter, error) {
	if s.Filter == nil || *s.Filter == "" {
		return nil, nil
	}

	length := len(fieldMap)
	var fields map[string]string
	for i := length - 1; i >= 0; i-- {
		if fieldMap[i] != nil {
			fields = fieldMap[i]
			break
		}
	}

	var err error
	filters := strings.Split(*s.Filter, ",")
	for k, v := range filters {
		if tmp, der := hex.DecodeString(v); der != nil {
			return nil, der
		} else {
			filters[k] = string(tmp)
		}
	}

	filter := hey.F()

	for _, v := range filters {
		match := filterRegexp.FindAllStringSubmatch(v, -1)
		length = len(match)
		if length != 1 {
			continue
		}
		matched := match[0]
		length = len(matched)
		if length != 5 {
			continue
		}
		field := matched[1]
		if fields != nil {
			tmp, ok := fields[field]
			if !ok {
				continue
			}
			if tmp != "" {
				field = tmp
			}
		}
		var values []interface{}
		switch matched[2] { // 根据 数据类型 解析 数据值
		case "i": // integer
			if values, err = parseInteger(matched[4]); err != nil {
				return nil, err
			}
		case "d": // double
			if values, err = parseDouble(matched[4]); err != nil {
				return nil, err
			}
		case "b": // bool
			if values, err = parseBool(matched[4]); err != nil {
				return nil, err
			}
		default: // string
			values = parseString(matched[4])
		}
		// 条件过滤类型
		switch matched[3] {
		case "00":
			filter.IsNull(field)
		case "01":
			filter.IsNotNull(field)
		case "11":
			if len(values) == 1 {
				filter.Equal(field, values[0])
			}
		case "12":
			if len(values) == 1 {
				filter.GreaterEqual(field, values[0])
			}
		case "13":
			if len(values) == 1 {
				filter.LessThanEqual(field, values[0])
			}
		case "14":
			if len(values) == 1 {
				filter.NotEqual(field, values[0])
			}
		case "15":
			if len(values) == 1 {
				filter.Like(field, fmt.Sprintf("%%%s%%", values[0]))
			}
		case "16":
			if len(values) == 1 {
				filter.NotLike(field, fmt.Sprintf("%%%s%%", values[0]))
			}
		case "20":
			if len(values) == 2 {
				filter.Between(field, values[0], values[1])
			}
		case "21":
			if len(values) == 2 {
				filter.NotBetween(field, values[0], values[1])
			}
		case "30":
			filter.In(field, values...)
		case "31":
			filter.NotIn(field, values...)
		default:
		}
	}

	return filter, nil
}

// OfMaxId 最大索引值,用于查询(表中数据条数超过OfLimitOffset.Offset值时的查询) 根据索引值倒序查询
// SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
type OfMaxId struct {
	OfMaxId *int64 `json:"max_id,string" query:"max_id" form:"max_id" validate:"omitempty"` // 最大id值,不包含当前值
}

// OfMinId 最小索引值,用于查询(表中数据条数超过OfLimitOffset.Offset值时的查询) 根据索引值顺序查询
// SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id > 5000000 ) ORDER BY id DESC )
type OfMinId struct {
	OfMinId *int64 `json:"min_id,string" query:"min_id" form:"mid_id" validate:"omitempty"` // 最小id值,不包含当前值
}

// OfCount 统计满足条件的总条数
type OfCount struct {
	Count bool `json:"count" query:"count" form:"count" validate:"-"` // 是否统计总条数
}

// OfOrder 检索数据排序
type OfOrder struct {
	Order *string `json:"order" query:"order" form:"order" validate:"omitempty,min=1,max=255"` // 排序
}

// OfLimit 控制数据列表返回的数据;如果数据超过offset的最大值,应该考虑换个方式查询分页数据如: SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
type OfLimit struct {
	Limit int64 `json:"limit" query:"limit" form:"limit" validate:"omitempty,min=1,max=1000"` // 数据条数
}

func (s OfLimit) GetLimit() int64 {
	if s.Limit <= 0 {
		return 1
	}
	return s.Limit
}

// OfOffset 控制数据列表返回的数据;如果数据超过offset的最大值,应该考虑换个方式查询分页数据如: SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
type OfOffset struct {
	Offset int64 `json:"offset" query:"offset" form:"offset" validate:"omitempty,min=0,max=100000"` // 数据偏移量
}

func (s OfOffset) GetOffset() int64 {
	if s.Offset < 0 {
		return 0
	}
	return s.Offset
}

/*
 *
 * 参数验证器
 *
 */

type Validator struct {
	Validator *validator.Validate
}

func (s *Validator) Validate(i interface{}) error {
	return s.Validator.Struct(i)
}

func NewValidator() (validate *Validator, err error) {
	validate = &Validator{
		Validator: validator.New(),
	}

	/*
	 * 1. string类型字段非必填时必须要在最前面加 "omitempty"
	 * 2. []string 要加 "dive" 才会生效
	 * 3. 有空格的字符串不能使用 "alpha"
	 * 4. []map[string]string 类型需要使用两个 dive 才能控制 key 和 value 的校验规则
	 */

	// 自定义校验规则

	// 校验GET请求的query参数order
	err = validate.Validator.RegisterValidation(
		"order",
		func(fl validator.FieldLevel) bool {
			field := fl.Field()
			switch field.Kind() {
			case reflect.String:
				return regexp.MustCompile(`^([a-zA-Z][A-Za-z0-9_]{0,29}:[ad])(,[a-zA-Z][A-Za-z0-9_]{0,29}:[ad])*$`).MatchString(field.String())
			default:
				return false
			}
		},
	)
	if err != nil {
		return
	}

	return
}

/*
 *
 * 参数验绑定+证器
 *
 */

type Binder struct {
	trans          ut.Translator
	validate       *validator.Validate
	defaultBuilder echo.Binder
}

func NewBinder() (echo.Binder, error) {
	uni := ut.New(zh.New())
	trans, _ := uni.GetTranslator("zh")
	vld, err := NewValidator()
	if err != nil {
		return nil, err
	}
	b := &Binder{
		trans:          trans,
		validate:       vld.Validator,
		defaultBuilder: &echo.DefaultBinder{},
	}
	if err = tzh.RegisterDefaultTranslations(b.validate, b.trans); err != nil {
		return nil, err
	}
	b.validate.RegisterTagNameFunc(func(fld reflect.StructField) string {
		tag := fld.Tag.Get("json")
		if tag != "" && tag != "-" {
			for _, v := range strings.Split(tag, ",") {
				if v != "omitempty" {
					return v
				}
			}
		}
		return fld.Name
	})
	return b, nil
}

// Bind for bind and validate request parameter
func (s *Binder) Bind(i interface{}, c echo.Context) error {
	if err := s.defaultBuilder.Bind(i, c); err != nil {
		return fmt.Errorf("param format parsing failed")
	}
	refValue := reflect.ValueOf(i)
	refKind := refValue.Kind()
	for refKind == reflect.Pointer {
		refValue = refValue.Elem()
		refKind = refValue.Kind()
	}
	if refKind == reflect.Slice {
		for index := 0; index < refValue.Len(); index++ {
			if err := s.validator(refValue.Index(index).Interface()); err != nil {
				return err
			}
		}
		return nil
	}
	if refKind == reflect.Struct {
		if err := s.validator(i); err != nil {
			return err
		}
		return nil
	}
	return fmt.Errorf("unsupported binding type: %s", reflect.ValueOf(i).Type().String())
}

// validator validate request parameter
func (s *Binder) validator(i interface{}) error {
	refType := reflect.TypeOf(i)
	refKind := refType.Kind()
	for refKind == reflect.Pointer {
		refType = refType.Elem()
		refKind = refType.Kind()
	}
	if refKind != reflect.Struct {
		return nil
	}
	if err := s.validate.Struct(i); err != nil {
		var tmp validator.ValidationErrors
		if !errors.As(err, &tmp) {
			return err
		}
		for _, v := range tmp {
			return fmt.Errorf("%s", v.Translate(s.trans)) // try to translate the error message
		}
	}
	return nil
}

/*
 *
 * 响应数据
 *
 */

const (
	CodeSuccess = 0 // 处理成功
	CodeFail    = 1 // 处理失败
	CodeError   = 2 // 服务器出错
	CodeUnusual = 3 // 其它业务异常
	CodeBad     = 4 // 客户端参数异常
)

const (
	MsgSuccess = "SUCCESS"
)

type Resp struct {
	Code    int         `json:"code" xml:"code" validate:"required,min=0"`                        // 业务状态码
	Message string      `json:"message" xml:"message" validate:"required"`                        // 业务描述语
	Data    interface{} `json:"data,omitempty" xml:"data,omitempty" validate:"omitempty"`         // 业务数据包
	Count   *int64      `json:"count,omitempty" xml:"count,omitempty" validate:"omitempty,min=0"` // 业务数据总条数
}

type Ctx struct {
	echo.Context

	ReqId string // request id

	Uid    int64  // store account id for int64 type
	UidStr string // store account id for string type

	status int // http status code

	resp *Resp // response content
}

func Echo4(c echo.Context) *Ctx {
	ctx, ok := c.(*Ctx)
	if ok && ctx != nil {
		return ctx
	}
	return &Ctx{
		Context: c,
		resp:    &Resp{},
	}
}

// clean clear the property values of the current object
func (s *Ctx) clean() {
	s.Context = nil
	s.ReqId = ""
	s.Uid = 0
	s.UidStr = ""
	s.status = 0
	s.resp.Code = 0
	s.resp.Message = ""
	s.resp.Data = nil
	s.resp.Count = nil
}

func (s *Ctx) HttpStatus(status int) *Ctx {
	s.status = status
	return s
}

func (s *Ctx) Code(code int) *Ctx {
	s.resp.Code = code
	return s
}

func (s *Ctx) Msg(msg string) *Ctx {
	s.resp.Message = msg
	return s
}

func (s *Ctx) Count(count int64) *Ctx {
	s.resp.Count = &count
	return s
}

func (s *Ctx) Data(data interface{}) *Ctx {
	s.resp.Data = data
	return s
}

func (s *Ctx) Json() error {
	defer s.clean()
	return s.JSON(s.status, s.resp)
}

func (s *Ctx) Bad(err error) error {
	msg := err.Error()
	if logger := s.Logger(); logger != nil {
		logger.Warnf("%s --> %s", s.Context.Path(), msg)
	}
	return s.HttpStatus(http.StatusOK).Code(CodeBad).Msg(msg).Json()
}

func (s *Ctx) Ok() error {
	return s.HttpStatus(http.StatusOK).Code(CodeSuccess).Msg(MsgSuccess).Json()
}

func (s *Ctx) Err(err error) error {
	if logger := s.Logger(); logger != nil {
		logger.Errorf("%s --> %s", s.Context.Path(), err.Error())
	}
	return s.HttpStatus(http.StatusInternalServerError).Code(CodeError).Msg(http.StatusText(http.StatusInternalServerError)).Json()
}

func (s *Ctx) Fail(msg string) error {
	return s.HttpStatus(http.StatusOK).Code(CodeFail).Msg(msg).Json()
}

func (s *Ctx) Unusual(err error) error {
	msg := err.Error()
	if logger := s.Logger(); logger != nil {
		logger.Warnf("%s --> %s", s.Context.Path(), msg)
	}
	return s.HttpStatus(http.StatusOK).Code(CodeUnusual).Msg(msg).Json()
}

package rest

import (
    "encoding/hex"
    "errors"
    "fmt"
    "regexp"
    "strconv"
    "strings"

    "github.com/cd365/hey"
)

// OfField 查询字段列表
type OfField struct {
	Field *string `json:"field" query:"field" form:"field" validate:"omitempty,min=1,max=1000"` // 查询字段列表(多个字段使用","分割)
}

// OfWhere 检索条件过滤
type OfWhere struct {
	Filter  *string `json:"filter" query:"filter" form:"filter" validate:"omitempty,min=1,max=8192"` // 条件过滤
	matched [][][]string
}

// filterRegexp 列名:[数据类型]条件类型:[条件值] 条件值存在多个使用","分割
var filterRegexp = regexp.MustCompile(`^([0-9])?(#)?([a-zA-Z][a-zA-Z0-9_]*):([%0-9A-F]*)?$`)

/*
number && string && null
(number) 0: IN (包含=)
(string) 1: IN (包含=)
(number) 2: BETWEEN AND
(number) 3: >
(number) 4: >=
(number) 5: <
(number) 6: <=
(string) 7: LIKE
(null) 	 8: IS NULL
#: 浮点类型
*/

func integer3(bts []byte) ([]interface{}, error) {
	splits := strings.Split(string(bts), ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		i64, err := strconv.ParseInt(splits[i], 10, 64)
		if err != nil {
			return nil, err
		}
		result = append(result, i64)
	}
	return result, nil
}

func double3(bts []byte) ([]interface{}, error) {
	splits := strings.Split(string(bts), ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		f64, err := strconv.ParseFloat(splits[i], 64)
		if err != nil {
			return nil, err
		}
		result = append(result, f64)
	}
	return result, nil
}

func number3(bts []byte, floatValue bool) ([]interface{}, error) {
	if floatValue {
		return double3(bts)
	}
	return integer3(bts)
}

func string3(bts []byte) []interface{} {
	splits := strings.Split(string(bts), ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		result = append(result, splits[i])
	}
	return result
}

func (s OfWhere) match() error {
	if s.matched != nil {
		return nil
	}
	if s.Filter == nil || *s.Filter == "" {
		return nil
	}
	queries := strings.Split(*s.Filter, ",")
	length := len(queries)
	s.matched = make([][][]string, 0, length)
	for i := 0; i < length; i++ {
		item, err := hex.DecodeString(queries[i])
		if err != nil {
			return err
		}
		tmp := filterRegexp.FindAllStringSubmatch(string(item), -1)
		if len(tmp) < 5 {
			continue
		}
		s.matched = append(s.matched, tmp)
	}
	return nil
}

var (
	ErrInvalidFilterValue = errors.New("invalid filter value")
)

// GetWhere 解析检索条件 ---> 使用","切割多个被 hex.EncodeToString([]byte(v)) 的字符串, v是满足 filterRegexp 正则表达式的条件字符串
func (s OfWhere) GetWhere(fieldRename ...map[string]string) (hey.Filter, error) {
	if err := s.match(); err != nil {
		return nil, err
	}
	count := len(s.matched)
	if count == 0 {
		return nil, nil
	}

	var fields map[string]string
	{
		length := len(fieldRename)
		for i := 0; i < length; i++ {
			if fieldRename[i] != nil {
				if fields == nil {
					fields = fieldRename[i]
				} else {
					for k, v := range fieldRename[i] {
						fields[k] = v
					}
				}
			}
		}
	}

	var err error
	var bts []byte
	var field string         // 字段名
	var values []interface{} // 字段值
	var group []string       // [0-9][F]field:[values]

	filter := hey.F()

	length := len(s.matched)
loop:
	for i := 0; i < length; i++ {
		group = s.matched[i][0]
		field = group[3]
		if fields != nil {
			tmp, ok := fields[field]
			if !ok {
				continue
			}
			if tmp != "" {
				field = tmp // field name redress
			}
		}
		// 提取参数值列表
		switch group[1][0] {
		case '0', '2', '3', '4', '5', '6':
			if bts, err = hex.DecodeString(group[4]); err != nil {
				return nil, err
			}
			if values, err = number3(bts, group[2] != ""); err != nil {
				return nil, err
			}
		case '1', '7':
			if bts, err = hex.DecodeString(group[4]); err != nil {
				return nil, err
			}
			values = string3(bts)
		case '8':
			values = nil
		default:
			continue loop
		}
		switch group[1][0] {
		case '0', '1': // IN || EQUAL
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.In(field, values...)
		case '2': // BETWEEN AND
			if len(values) != 2 {
				return nil, ErrInvalidFilterValue
			}
			filter.Between(field, values[0], values[1])
		case '3': // >
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.Greater(field, values[0])
		case '4': // >=
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.GreaterEqual(field, values[0])
		case '5': // <
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.LessThan(field, values[0])
		case '6': // <=
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.LessThanEqual(field, values[0])
		case '7': // LIKE
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.Like(field, fmt.Sprintf("%%%s%%", values[0]))
		case '8': // IS NULL
			filter.IsNull(field)
		}
	}

	return filter, nil
}

// OfMaxId 最大索引值,用于查询(表中数据条数超过OfLimitOffset.Offset值时的查询) 根据索引值倒序查询
// SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
type OfMaxId struct {
	OfMaxId *int64 `json:"max_id,string" query:"max_id" form:"max_id" validate:"omitempty"` // 最大id值,不包含当前值
}

// OfMinId 最小索引值,用于查询(表中数据条数超过OfLimitOffset.Offset值时的查询) 根据索引值顺序查询
// SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id > 5000000 ) ORDER BY id DESC )
type OfMinId struct {
	OfMinId *int64 `json:"min_id,string" query:"min_id" form:"mid_id" validate:"omitempty"` // 最小id值,不包含当前值
}

// OfCount 统计满足条件的总条数
type OfCount struct {
	Count bool `json:"count" query:"count" form:"count" validate:"-"` // 是否统计总条数
}

// OfOrder 检索数据排序
type OfOrder struct {
	Order *string `json:"order" query:"order" form:"order" validate:"omitempty,min=1,max=255"` // 排序
}

// OfLimit 控制数据列表返回的数据;如果数据超过offset的最大值,应该考虑换个方式查询分页数据如: SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
type OfLimit struct {
	Limit int64 `json:"limit" query:"limit" form:"limit" validate:"omitempty,min=1,max=1000"` // 数据条数
}

func (s OfLimit) GetLimit() int64 {
	if s.Limit <= 0 {
		return 1
	}
	return s.Limit
}

// OfOffset 控制数据列表返回的数据;如果数据超过offset的最大值,应该考虑换个方式查询分页数据如: SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
type OfOffset struct {
	Offset int64 `json:"offset" query:"offset" form:"offset" validate:"omitempty,min=0,max=100000"` // 数据偏移量
}

func (s OfOffset) GetOffset() int64 {
	if s.Offset < 0 {
		return 0
	}
	return s.Offset
}

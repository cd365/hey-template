package rest

import (
	"encoding/hex"
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/cd365/hey"
	"github.com/go-playground/validator/v10"
)

// OfField 查询字段列表
type OfField struct {
	Field *string `json:"field" query:"field" form:"field" validate:"omitempty,min=1,max=1000"` // 查询字段列表(多个字段使用","分割)
}

// OfWhere 检索条件过滤
type OfWhere struct {
	Filter *string `json:"filter" query:"filter" form:"filter" validate:"omitempty,min=1,max=8192"` // 条件过滤
}

// filterRegexp 列名:[数据类型]条件类型:[条件值]
// 条件值存在多个使用","分割
var filterRegexp = regexp.MustCompile(`^([a-zA-Z][a-zA-Z0-9_]*):([idb]?)([ABC0123456789DEF]{2}):(.*)$`)

func parseInteger(str string) ([]interface{}, error) {
	splits := strings.Split(str, ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		i64, err := strconv.ParseInt(splits[i], 10, 64)
		if err != nil {
			return nil, err
		}
		result = append(result, i64)
	}
	return result, nil
}

func parseDouble(str string) ([]interface{}, error) {
	splits := strings.Split(str, ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		f64, err := strconv.ParseFloat(splits[i], 64)
		if err != nil {
			return nil, err
		}
		result = append(result, f64)
	}
	return result, nil
}

func parseBool(str string) ([]interface{}, error) {
	splits := strings.Split(str, ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		bol, err := strconv.ParseBool(splits[i])
		if err != nil {
			return nil, err
		}
		result = append(result, bol)
	}
	return result, nil
}

func parseString(str string) []interface{} {
	splits := strings.Split(str, ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		result = append(result, splits[i])
	}
	return result
}

// GetWhere 解析检索条件 ---> 使用","切割多个被 hex.EncodeToString([]byte(v)) 的字符串, v是满足 filterRegexp 正则表达式的条件字符串
func (s OfWhere) GetWhere(fieldMap ...map[string]string) (hey.Filter, error) {
	if s.Filter == nil || *s.Filter == "" {
		return nil, nil
	}

	length := len(fieldMap)
	var fields map[string]string
	for i := length - 1; i >= 0; i-- {
		if fieldMap[i] != nil {
			fields = fieldMap[i]
			break
		}
	}

	var err error
	filters := strings.Split(*s.Filter, ",")
	for k, v := range filters {
		if tmp, der := hex.DecodeString(v); der != nil {
			return nil, der
		} else {
			filters[k] = string(tmp)
		}
	}

	filter := hey.F()

	for _, v := range filters {
		match := filterRegexp.FindAllStringSubmatch(v, -1)
		length = len(match)
		if length != 1 {
			continue
		}
		matched := match[0]
		length = len(matched)
		if length != 5 {
			continue
		}
		field := matched[1]
		if fields != nil {
			tmp, ok := fields[field]
			if !ok {
				continue
			}
			if tmp != "" {
				field = tmp
			}
		}
		var values []interface{}
		switch matched[2] { // 根据 数据类型 解析 数据值
		case "i": // integer
			if values, err = parseInteger(matched[4]); err != nil {
				return nil, err
			}
		case "d": // double
			if values, err = parseDouble(matched[4]); err != nil {
				return nil, err
			}
		case "b": // bool
			if values, err = parseBool(matched[4]); err != nil {
				return nil, err
			}
		default: // string
			values = parseString(matched[4])
		}
		// 条件过滤类型
		switch matched[3] {
		case "00":
			filter.IsNull(field)
		case "01":
			filter.IsNotNull(field)
		case "11":
			if len(values) == 1 {
				filter.Equal(field, values[0])
			}
		case "12":
			if len(values) == 1 {
				filter.GreaterEqual(field, values[0])
			}
		case "13":
			if len(values) == 1 {
				filter.LessThanEqual(field, values[0])
			}
		case "14":
			if len(values) == 1 {
				filter.NotEqual(field, values[0])
			}
		case "15":
			if len(values) == 1 {
				filter.Like(field, fmt.Sprintf("%%%s%%", values[0]))
			}
		case "16":
			if len(values) == 1 {
				filter.NotLike(field, fmt.Sprintf("%%%s%%", values[0]))
			}
		case "20":
			if len(values) == 2 {
				filter.Between(field, values[0], values[1])
			}
		case "21":
			if len(values) == 2 {
				filter.NotBetween(field, values[0], values[1])
			}
		case "30":
			filter.In(field, values...)
		case "31":
			filter.NotIn(field, values...)
		default:
		}
	}

	return filter, nil
}

// OfMaxId 最大索引值,用于查询(表中数据条数超过OfLimitOffset.Offset值时的查询) 根据索引值倒序查询
// SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
type OfMaxId struct {
	OfMaxId *int64 `json:"max_id,string" query:"max_id" form:"max_id" validate:"omitempty"` // 最大id值,不包含当前值
}

// OfMinId 最小索引值,用于查询(表中数据条数超过OfLimitOffset.Offset值时的查询) 根据索引值顺序查询
// SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id > 5000000 ) ORDER BY id DESC )
type OfMinId struct {
	OfMinId *int64 `json:"min_id,string" query:"min_id" form:"mid_id" validate:"omitempty"` // 最小id值,不包含当前值
}

// OfCount 统计满足条件的总条数
type OfCount struct {
	Count bool `json:"count" query:"count" form:"count" validate:"-"` // 是否统计总条数
}

// OfOrder 检索数据排序
type OfOrder struct {
	Order *string `json:"order" query:"order" form:"order" validate:"omitempty,min=1,max=255"` // 排序
}

// OfLimit 控制数据列表返回的数据;如果数据超过offset的最大值,应该考虑换个方式查询分页数据如: SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
type OfLimit struct {
	Limit int64 `json:"limit" query:"limit" form:"limit" validate:"omitempty,min=1,max=1000"` // 数据条数
}

func (s OfLimit) GetLimit() int64 {
	if s.Limit <= 0 {
		return 1
	}
	return s.Limit
}

// OfOffset 控制数据列表返回的数据;如果数据超过offset的最大值,应该考虑换个方式查询分页数据如: SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
type OfOffset struct {
	Offset int64 `json:"offset" query:"offset" form:"offset" validate:"omitempty,min=0,max=100000"` // 数据偏移量
}

func (s OfOffset) GetOffset() int64 {
	if s.Offset < 0 {
		return 0
	}
	return s.Offset
}

/*
 *
 * 参数验证器
 *
 */

type Validator struct {
	Validator *validator.Validate
}

func (s *Validator) Validate(i interface{}) error {
	return s.Validator.Struct(i)
}

func NewValidator() (validate *Validator, err error) {
	validate = &Validator{
		Validator: validator.New(),
	}

	/*
	 * 1. string类型字段非必填时必须要在最前面加 "omitempty"
	 * 2. []string 要加 "dive" 才会生效
	 * 3. 有空格的字符串不能使用 "alpha"
	 * 4. []map[string]string 类型需要使用两个 dive 才能控制 key 和 value 的校验规则
	 */

	// 自定义校验规则

	// 校验GET请求的query参数order
	err = validate.Validator.RegisterValidation(
		"order",
		func(fl validator.FieldLevel) bool {
			field := fl.Field()
			switch field.Kind() {
			case reflect.String:
				return regexp.MustCompile(`^([a-zA-Z][A-Za-z0-9_]{0,29}:[ad])(,[a-zA-Z][A-Za-z0-9_]{0,29}:[ad])*$`).MatchString(field.String())
			default:
				return false
			}
		},
	)
	if err != nil {
		return
	}

	return
}

// hey-template version: {{{.Version}}}
// TEMPLATE CODE DO NOT EDIT IT.

package data

import (
	"context"
    "database/sql"

	"github.com/cd365/g"
	"github.com/cd365/hey"

	"{{{.PrefixPackage}}}/model"
)

type {{{.OriginNamePascal}}} struct {
	schema *schema
	gg *g.GoGroup
	T *model.{{{.OriginNamePascal}}}Schema
	W *hey.Way
}

// New{{{.OriginNamePascal}}} {{{.OriginName}}} {{{.Comment}}}
func New{{{.OriginNamePascal}}}(
	ctx context.Context,
	gg *g.GoGroup,
	table *model.{{{.OriginNamePascal}}}Schema,
	way *hey.Way,
) (*{{{.OriginNamePascal}}}, error) {
	s := &{{{.OriginNamePascal}}}{
	    schema: &schema{},
		gg: gg,
		T: table,
		W: way,
	}
	{
        s.schema.insertExceptColumns = s.AddExcept()
        s.schema.updateExceptColumns = s.ModExcept()
        s.schema.insertPermitColumns = s.Column(s.schema.insertExceptColumns...)
        s.schema.selectPermitColumns = s.Column(s.schema.selectExceptColumns...)
        s.schema.deleteFilter = s.F()
        s.schema.updateFilter = s.F()
        s.schema.selectFilter = s.F()
        for _, field := range s.DeletedAt() {
            s.schema.deleteFilter.Equal(field, 0)
            s.schema.updateFilter.Equal(field, 0)
            s.schema.selectFilter.Equal(field, 0)
        }
        s.schema.deleteForbidMsg = "请勿删除系统数据"
        s.schema.updateForbidMsg = "请勿更新系统数据"
    }
	if err := s.ofStart(ctx);err != nil {
		return nil, err
	}
	return s, nil
}

// F create a Filter.
func (s *{{{.OriginNamePascal}}}) F(filters ...hey.Filter) hey.Filter {
	return s.W.F(filters...)
}

// In create a Filter by 'IN' keyword.
func (s *{{{.OriginNamePascal}}}) In(field string, values ...interface{}) hey.Filter {
	return s.F().In(field, values...)
}

// Add new *Add object.
func (s *{{{.OriginNamePascal}}}) Add(way ...*hey.Way) *hey.Add {
	return AutoWay(s.W, way...).Add(s.T.Table())
}

// Del new *Del object.
func (s *{{{.OriginNamePascal}}}) Del(way ...*hey.Way) *hey.Del {
	return AutoWay(s.W, way...).Del(s.T.Table())
}

// Mod new *Mod object.
func (s *{{{.OriginNamePascal}}}) Mod(way ...*hey.Way) *hey.Mod {
	return AutoWay(s.W, way...).Mod(s.T.Table())
}

// Get new *Get object.
func (s *{{{.OriginNamePascal}}}) Get(way ...*hey.Way) *hey.Get {
	return AutoWay(s.W, way...).Get(s.T.Table()).Column(s.T.Column()...)
}

// Table Get the current instance table name.
func (s *{{{.OriginNamePascal}}}) Table() string {
    return s.T.Table()
}

// Comment Get the current instance table comment.
func (s *{{{.OriginNamePascal}}}) Comment() string {
	return s.T.Comment()
}

// Column Get the column list of the current table(allow some columns to be ignored).
func (s *{{{.OriginNamePascal}}}) Column(except ...string) []string {
    return s.T.Column(except...)
}

// ColumnMap Get the column of the current table map.
func (s *{{{.OriginNamePascal}}}) ColumnMap() map[string]*struct{} {
	return s.T.ColumnMap()
}

// ColumnExist Detect whether the current instance exists in a certain column.
func (s *{{{.OriginNamePascal}}}) ColumnExist(field string) bool {
    return s.T.ColumnExist(field)
}

// CreatedAt Insert timestamp fields list(field value type: int4 or int8).
func (s *{{{.OriginNamePascal}}}) CreatedAt() []string {
	return s.T.ColumnCreatedAt()
}

// UpdatedAt Update timestamp fields list(field value type: int4 or int8).
func (s *{{{.OriginNamePascal}}}) UpdatedAt() []string {
	return s.T.ColumnUpdatedAt()
}

// DeletedAt Delete timestamp fields list(field value type: int4 or int8).
func (s *{{{.OriginNamePascal}}}) DeletedAt() []string {
	return s.T.ColumnDeletedAt()
}

// AddExcept List of fields to insert data to be ignored.
func (s *{{{.OriginNamePascal}}}) AddExcept() []string {
	return s.T.ColumnAutoIncr()
}

// ModExcept List of fields to update data to be ignored.
func (s *{{{.OriginNamePascal}}}) ModExcept() (result []string) {
	result = s.AddExcept()
	result = append(result, s.T.ColumnCreatedAt()...)
	return
}

// AddAt Set the default timestamp when inserting the data.
func (s *{{{.OriginNamePascal}}}) AddAt(add *hey.Add, way ...*hey.Way) {
	timestamp := AutoWay(s.W, way...).Now().Unix()
	for _, field := range s.CreatedAt() {
		add.Default(func(o *hey.Add) { o.FieldValue(field, timestamp) })
	}
	for _, field := range s.UpdatedAt() {
		add.Default(func(o *hey.Add) { o.FieldValue(field, timestamp) })
	}
}

// ModAt Set the default timestamp when updating the data.
func (s *{{{.OriginNamePascal}}}) ModAt(mod *hey.Mod, way ...*hey.Way) {
	timestamp := AutoWay(s.W, way...).Now().Unix()
	for _, field := range s.UpdatedAt() {
		mod.Default(func(o *hey.Mod) { o.Set(field, timestamp) })
	}
}

// NotExistsIndex Get the field index list that does not exist in the current instance in fields.
func (s *{{{.OriginNamePascal}}}) NotExistsIndex(fields []string) []int {
	result := make([]int, 0)
	for k, v := range fields {
		if !s.ColumnExist(v) {
			result = append(result, k)
		}
	}
	return result
}

// ExistsColumns Get a list of existing columns.
func (s *{{{.OriginNamePascal}}}) ExistsColumns(columns ...string) []string {
	length := len(columns)
    result := make([]string, 0, length)
    for i := 0; i < length; i++ {
        if s.ColumnExist(columns[i]) {
            result = append(result, columns[i])
        }
    }
    return result[:]
}

// Exists Check whether the data exists.
func (s *{{{.OriginNamePascal}}}) Exists(fc func(get *hey.Get, f hey.Filter), way ...*hey.Way) (bool, error) {
	query := s.Get(way...)
	filter := s.F()
	if fc != nil {
		fc(query, filter)
	}
	return query.Where(filter).Limit(1).Exists()
}

// Insert Quickly insert data.
func (s *{{{.OriginNamePascal}}}) Insert(insert interface{}, way ...*hey.Way) (int64, error) {
	return s.SelfInsert(func(add *hey.Add, t *model.{{{.OriginNamePascal}}}Schema) {
    		except := s.T.ColumnAutoIncr()
    		add.Except(except...).Permit(s.Column(except...)...).Create(insert)
    	}, way...)
}

// Delete Quickly delete data.
func (s *{{{.OriginNamePascal}}}) Delete(filter hey.Filter, way ...*hey.Way) (int64, error) {
	return s.Del(way...).Where(filter).Del()
}

// Update Quickly update data.
func (s *{{{.OriginNamePascal}}}) Update(filter hey.Filter, update map[string]interface{}, way ...*hey.Way) (int64, error) {
	return s.SelfUpdate(func(mod *hey.Mod, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema) {
		f.Use(filter)
        mod.Modify(update)
	}, way...)
}

// Select Quickly select data.
func (s *{{{.OriginNamePascal}}}) Select(get func(get *hey.Get), query func(rows *sql.Rows) error, way ...*hey.Way) error {
	tmp := s.Get(way...)
	get(tmp)
	return tmp.Query(query)
}

// SelectGet Quickly select data to result.
func (s *{{{.OriginNamePascal}}}) SelectGet(get func(get *hey.Get), result interface{}, way ...*hey.Way) error {
	tmp := s.Get(way...)
	get(tmp)
	return tmp.Get(result)
}

// Count Quickly COUNT(*) data.
func (s *{{{.OriginNamePascal}}}) Count(filter hey.Filter, way ...*hey.Way) (int64, error) {
	return s.Get(way...).Where(filter).Count()
}

// InsertMust Quickly insert data(affectedRows > 0).
func (s *{{{.OriginNamePascal}}}) InsertMust(insert interface{}, way ...*hey.Way) error {
	return hey.MustAffectedRows(s.Insert(insert, way...))
}

// DeleteMust Quickly delete data(affectedRows > 0).
func (s *{{{.OriginNamePascal}}}) DeleteMust(filter hey.Filter, way ...*hey.Way) error {
	return hey.MustAffectedRows(s.Delete(filter, way...))
}

// UpdateMust Quickly update data(affectedRows > 0).
func (s *{{{.OriginNamePascal}}}) UpdateMust(filter hey.Filter, update map[string]interface{}, way ...*hey.Way) error {
	return hey.MustAffectedRows(s.Update(filter, update, way...))
}

// SelfExists Check whether the data exists(only current instance).
func (s *{{{.OriginNamePascal}}}) SelfExists(fc func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (bool, error) {
	query := s.Get(way...)
	filter := s.F()
	if fc != nil {
		fc(query, filter, s.T)
	}
	return query.Where(filter).Limit(1).Exists()
}

// SelfInsert Quickly insert data(only current instance).
func (s *{{{.OriginNamePascal}}}) SelfInsert(fc func(add *hey.Add, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (int64, error) {
	tmp := s.Add(way...).Except(s.AddExcept()...)
	fc(tmp, s.T)
	s.AddAt(tmp, way...)
	return tmp.Add()
}

// SelfDelete Quickly delete data(only current instance).
func (s *{{{.OriginNamePascal}}}) SelfDelete(fc func(del *hey.Del, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (int64, error) {
	tmp := s.Del(way...)
	where := s.F()
    fc(tmp, where, s.T)
    if !where.IsEmpty() {
        tmp.Where(where)
    }
	return tmp.Del()
}

// SelfUpdate Quickly update data(only current instance).
func (s *{{{.OriginNamePascal}}}) SelfUpdate(fc func(mod *hey.Mod, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (int64, error) {
	tmp := s.Mod(way...).Except(s.ModExcept()...)
	where := s.F()
    fc(tmp, where, s.T)
    s.ModAt(tmp, way...)
    if !where.IsEmpty() {
        tmp.Where(where)
    }
	return tmp.Mod()
}

// SelfGetAll Quickly select all data(only current instance).
func (s *{{{.OriginNamePascal}}}) SelfGetAll(query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (result []*model.{{{.OriginNamePascal}}}, err error) {
	tmp := s.Get(way...)
	where := s.F()
    query(tmp, where, s.T)
    if !where.IsEmpty() {
        tmp.Where(where)
    }
    err = tmp.Get(&result)
	return
}

// SelfGetOne Quickly select one data(only current instance).
func (s *{{{.OriginNamePascal}}}) SelfGetOne(query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (*model.{{{.OriginNamePascal}}}, error) {
	tmp, err := s.SelfGetAll(func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema) {
		query(get, f, t)
		get.Limit(1)
	}, way...)
	if err != nil {
		return nil, err
	}
	if len(tmp) > 0 {
		return tmp[0], nil
	}
	return nil, nil
}

// SelfSubGet Build query objects based on the current instance basic query(only current instance).
func (s *{{{.OriginNamePascal}}}) SelfSubGet(query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema)) *hey.Get {
	get := s.Get()
	where := s.F()
    if query != nil {
        query(get, where, s.T)
        if !where.IsEmpty() {
            get.Where(where)
        }
    }
	return get
}

// SelfInsertMust Quickly insert data(affectedRows > 0, only current instance).
func (s *{{{.OriginNamePascal}}}) SelfInsertMust(fc func(add *hey.Add, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) error {
	return hey.MustAffectedRows(s.SelfInsert(fc, way...))
}

// SelfDeleteMust Quickly delete data(affectedRows > 0, only current instance).
func (s *{{{.OriginNamePascal}}}) SelfDeleteMust(fc func(del *hey.Del, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) error {
	return hey.MustAffectedRows(s.SelfDelete(fc, way...))
}

// SelfUpdateMust Quickly update data(affectedRows > 0, only current instance).
func (s *{{{.OriginNamePascal}}}) SelfUpdateMust(fc func(mod *hey.Mod, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) error {
	return hey.MustAffectedRows(s.SelfUpdate(fc, way...))
}

// SelfGetAllMust Quickly select all data(only current instance).
func (s *{{{.OriginNamePascal}}}) SelfGetAllMust(query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) ([]*model.{{{.OriginNamePascal}}}, error) {
	tmp, err := s.SelfGetAll(query, way...)
	if err != nil {
		return nil, err
	}
	if len(tmp) == 0 {
		return nil, sql.ErrNoRows
	}
	return tmp, nil
}

// SelfGetOneMust Quickly select one data(only current instance).
func (s *{{{.OriginNamePascal}}}) SelfGetOneMust(query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (*model.{{{.OriginNamePascal}}}, error) {
	tmp, err := s.SelfGetOne(query, way...)
	if err != nil {
		return nil, err
	}
	if tmp == nil {
		return nil, sql.ErrNoRows
	}
	return tmp, nil
}

// SelfDeleteInsertAll Delete data and then insert in batches.
func (s *{{{.OriginNamePascal}}}) SelfDeleteInsertAll(allData interface{}, where func(f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), insert func(add *hey.Add, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) error {
	return s.SelfSelectDeleteInsertAll(allData, where, nil, nil, insert, way...)
}

// SelfSelectDeleteInsertAll Select data, delete data and then insert in batches.
func (s *{{{.OriginNamePascal}}}) SelfSelectDeleteInsertAll(
	allData interface{},
	where func(f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema),
	query func(get *hey.Get, t *model.{{{.OriginNamePascal}}}Schema),
	allList func(list []*model.{{{.OriginNamePascal}}}),
	insert func(add *hey.Add, t *model.{{{.OriginNamePascal}}}Schema),
	way ...*hey.Way,
) error {
	filter := s.F()
	where(filter, s.T)
	return AutoWay(s.W, way...).TxTry(func(tx *hey.Way) error {
		if query != nil && allList != nil {
			list, err := s.SelfGetAll(func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema) {
				f.Use(filter)
				query(get, t)
			})
			if err != nil {
				return err
			}
			allList(list)
		}
		if _, err := s.Delete(filter, tx); err != nil {
			return err
		}
		add := s.Add(tx)
		if insert != nil {
			insert(add, s.T)
		}
		if _, err := add.Create(allData).Add(); err != nil {
			return err
		}
		return nil
	})
}

// SelfUpdateInsertAll Update or insert.
func (s *{{{.OriginNamePascal}}}) SelfUpdateInsertAll(
	dataWhere []func() (
		data interface{},
		where func(f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema),
	),
	exists func(get *hey.Get, t *model.{{{.OriginNamePascal}}}Schema),
	insert func(add *hey.Add, t *model.{{{.OriginNamePascal}}}Schema),
	update func(mod *hey.Mod, t *model.{{{.OriginNamePascal}}}Schema),
	way ...*hey.Way,
) error {
	length := len(dataWhere)
	if length == 0 {
		return nil
	}
	columns := s.Column()
	return AutoWay(s.W, way...).TxTry(func(tx *hey.Way) error {
		for i := 0; i < length; i++ {
			if dataWhere[i] == nil {
				continue
			}
			data, where := dataWhere[i]()
			if data == nil || where == nil {
				continue
			}
			filter := s.F()
			where(filter, s.T)
			if filter.IsEmpty() {
				continue
			}
			has, err := s.SelfGetOne(func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema) {
				if exists != nil {
					exists(get, t)
				} else {
					get.Column(columns[0])
				}
				f.Use(filter)
			}, tx)
			if err != nil {
				return err
			}
			if has == nil {
				add := s.Add(tx)
				if insert != nil {
					insert(add, s.T)
				}
				_, err = add.Create(data).Add()
				if err != nil {
					return err
				}
			} else {
				_, err = s.SelfUpdate(func(mod *hey.Mod, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema) {
					if update != nil {
						update(mod, t)
					}
					f.Use(filter)
					mod.Modify(data)
				}, tx)
				if err != nil {
					return err
				}
			}
		}
		return nil
	})
}

// All methods using *schema are prefixed with `Of`.

// OfInsertExceptColumns 插入数据需要忽略的字段列表 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfInsertExceptColumns() []string {
	return s.schema.insertExceptColumns[:]
}

// OfUpdateExceptColumns 更新数据需要忽略的字段列表 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfUpdateExceptColumns() []string {
	return s.schema.updateExceptColumns[:]
}

// OfSelectExceptColumns 查询数据需要忽略的字段列表 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSelectExceptColumns() []string {
	return s.schema.selectExceptColumns[:]
}

// OfDeleteFilter 删除数据的前提条件(删除的数据必须满足当前方法返回的条件) (with *schema).
func (s *{{{.OriginNamePascal}}}) OfDeleteFilter() hey.Filter {
	return s.F(s.schema.deleteFilter)
}

// OfUpdateFilter 更新数据的前提条件(更新的数据必须满足当前方法返回的条件) (with *schema).
func (s *{{{.OriginNamePascal}}}) OfUpdateFilter() hey.Filter {
	return s.F(s.schema.updateFilter)
}

// OfSelectFilter 查询数据的前提条件(查询的数据必须满足当前方法返回的条件) (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSelectFilter() hey.Filter {
	return s.F(s.schema.selectFilter)
}

// OfDeleteForbidMsg 删除不允许删除的数据(提示语) (with *schema).
func (s *{{{.OriginNamePascal}}}) OfDeleteForbidMsg() string {
	return s.schema.deleteForbidMsg
}

// OfUpdateForbidMsg 更新不允许更新的数据(提示语) (with *schema).
func (s *{{{.OriginNamePascal}}}) OfUpdateForbidMsg() string {
	return s.schema.updateForbidMsg
}


// OfExists 检测数据是否存在 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfExists(ctx context.Context, fc func(f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (bool, error) {
	filter := s.F()
    if fc != nil {
        fc(filter, s.T)
    }
    return s.Get(way...).Context(ctx).Where(s.F(s.schema.selectFilter, filter)).Exists()
}

// OfInsert 插入数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfInsert(ctx context.Context, insert interface{}, way ...*hey.Way) (int64, error) {
	add := s.Add(way...).Context(ctx).Except(s.schema.insertExceptColumns...)
	if fieldValue, ok := insert.(map[string]interface{}); ok {
		allow := make(map[string]*struct{})
		for _, field := range s.schema.insertPermitColumns {
			allow[field] = &struct{}{}
		}
		allowed := len(allow) > 0
		num := 0
		for field, value := range fieldValue {
			if allowed {
				if _, ok = allow[field]; !ok {
					continue
				}
			}
			num++
			add.FieldValue(field, value)
		}
		if num == 0 {
			return 0, nil
		}
		s.AddAt(add, way...)
		return add.Add()
	}
	fields, values := hey.StructInsert(insert, s.W.Tag(), s.schema.insertExceptColumns, s.schema.insertPermitColumns)
	if len(fields) == 0 {
		return 0, nil
	}
	add.FieldsValues(fields, values)
	s.AddAt(add, way...)
	return add.Add()
}

// OfInsertMust 必须成功插入数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfInsertMust(ctx context.Context, insert interface{}, way ...*hey.Way) error {
	return hey.MustAffectedRows(s.OfInsert(ctx, insert, way...))
}

// OfDelete 删除数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfDelete(ctx context.Context, fc func(f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (int64, error) {
	return s.SelfDelete(func(del *hey.Del, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema) {
        del.Context(ctx)
        if fc != nil {
            fc(f, t)
        }
        if !f.IsEmpty() {
            f.Use(s.schema.deleteFilter)
        }
	}, way...)
}

// OfDeleteMust 必须成功删除数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfDeleteMust(ctx context.Context, fc func(f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) error {
	return hey.MustAffectedRows(s.OfDelete(ctx, fc, way...))
}

// OfUpdate 更新数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfUpdate(ctx context.Context, fc func(mod *hey.Mod, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (int64, error) {
	return s.SelfUpdate(func(mod *hey.Mod, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema) {
		mod.Context(ctx).Except(s.schema.updateExceptColumns...)
		if fc != nil {
			fc(mod, f, t)
		}
		if !f.IsEmpty() {
            f.Use(s.schema.updateFilter)
        }
	}, way...)
}

// OfUpdateMust 必须成功更新数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfUpdateMust(ctx context.Context, fc func(mod *hey.Mod, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) error {
	return hey.MustAffectedRows(s.OfUpdate(ctx, fc, way...))
}

// OfUpdate1 更新数据(通过map或结构体更新) (with *schema).
func (s *{{{.OriginNamePascal}}}) OfUpdate1(ctx context.Context, fc func(f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), update interface{}, way ...*hey.Way) (int64, error) {
	return s.OfUpdate(ctx, func(mod *hey.Mod, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema) {
		if modify, ok := update.(map[string]interface{}); ok {
			for k, v := range modify {
				if s.ColumnExist(k) {
					mod.Set(k, v)
				}
			}
		} else {
			fields, values := hey.StructModify(update, s.W.Tag(), s.schema.updateExceptColumns...)
			for index, field := range fields {
				if s.ColumnExist(field) {
					mod.Set(field, values[index])
				}
			}
		}
		if fc != nil {
			fc(f, t)
		}
	}, way...)
}

// OfUpdate1Must 必须成功更新数据(通过map或结构体更新) (with *schema).
func (s *{{{.OriginNamePascal}}}) OfUpdate1Must(ctx context.Context, fc func(f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), update interface{}, way ...*hey.Way) error {
	return hey.MustAffectedRows(s.OfUpdate1(ctx, fc, update, way...))
}

// OfSubGet 子查询对象 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSubGet(fc func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema)) *hey.Get {
	filter := s.F()
	subQuery := s.Get().Column(s.schema.selectPermitColumns...)
	if fc != nil {
		fc(subQuery, filter, s.T)
	}
	filter.Use(s.schema.selectFilter)
	return subQuery.Where(filter)
}

// OfSelect 查询数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSelect(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), takeOut func(get *hey.Get) error, way ...*hey.Way) error {
	filter := s.F()
	get := s.Get(way...).Context(ctx).Column(s.schema.selectPermitColumns...)
	if query != nil {
		query(get, filter, s.T)
	}
	filter.Use(s.schema.selectFilter)
	get.Where(filter)
	return takeOut(get)
}

// OfSelectOne 查询一条数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSelectOne(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (*model.{{{.OriginNamePascal}}}, error) {
    result := make([]*model.{{{.OriginNamePascal}}}, 0)
    if err := s.OfSelect(ctx, query, func(get *hey.Get) error {
        return get.Limit(1).Get(&result)
    }, way...); err != nil {
        return nil, err
    }
    if len(result) == 0 {
        return nil, nil
    }
    return result[0], nil
}

// OfSelectAll 查询多条数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSelectAll(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) ([]*model.{{{.OriginNamePascal}}}, error) {
    result := make([]*model.{{{.OriginNamePascal}}}, 0)
    if err := s.OfSelect(ctx, query, func(get *hey.Get) error {
        return get.Get(&result)
    }, way...); err != nil {
        return nil, err
    }
    return result, nil
}

// OfSelectGet 查询一条或多条数据, 通过反射把数据赋值到result (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSelectGet(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), result interface{}, way ...*hey.Way) error {
    return s.OfSelect(ctx, query, func(get *hey.Get) error {
        return get.Get(result)
    }, way...)
}

// OfSelectMap 查询一条或多条数据, 将数据存储到map[string]interface{}中 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSelectMap(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) ([]map[string]interface{}, error) {
	var result []map[string]interface{}
	if err := s.OfSelect(ctx, query, func(get *hey.Get) error {
		data, err := get.ViewMap()
		if err != nil {
			return err
		}
		result = data
		return nil
	}, way...); err != nil {
		return nil, err
	}
	return result, nil
}

// OfSelectMap1 查询一条或多条数据, 将数据存储到map[string]interface{}中, 单独处理空值[]map[string]interface{} (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSelectMap1(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) ([]map[string]interface{}, error) {
	result, err := s.OfSelectMap(ctx, query, way...)
	if err != nil {
		return nil, err
	}
	if result == nil {
		result = make([]map[string]interface{}, 0)
	}
	return result, nil
}

// OfSelectScanOne 查询一条数据, 把查询到的数据依次扫描到dest列表(变量地址)中 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSelectScanOne(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), dest []interface{}, way ...*hey.Way) error {
    return s.OfSelect(ctx, query, func(get *hey.Get) error {
        return get.ScanOne(dest...)
    }, way...)
}

// OfSelectScanAll 查询多条数据, 把查询到的数据交给scanAll处理, scanAll应该一次扫描数据到对应的变量地址上 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfSelectScanAll(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), scanAll func(rows *sql.Rows) error, way ...*hey.Way) error {
    return s.OfSelect(ctx, query, func(get *hey.Get) error {
        return get.ScanAll(scanAll)
    }, way...)
}

// OfCount 统计数据总条数 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfCount(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (count int64, err error) {
	err = s.OfSelect(ctx, query, func(get *hey.Get) error {
		count, err = get.Count()
		return err
	}, way...)
	return
}

// OfCountSelect 统计数据总条数并查询数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfCountSelect(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), takeOut func(get *hey.Get) error, way ...*hey.Way) (count int64, err error) {
    err = s.OfSelect(ctx, query, func(get *hey.Get) error {
        count, err = get.Count()
        if err != nil {
            return err
        }
        if count == 0 {
            return nil
        }
        return takeOut(get)
    }, way...)
    return
}

// OfCountSelectAll 统计数据总条数并查询多条数据 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfCountSelectAll(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (count int64, result []*model.{{{.OriginNamePascal}}}, err error) {
    count, err = s.OfCountSelect(ctx, query, func(get *hey.Get) error {
        return get.Get(&result)
    }, way...)
    return
}

// OfCountSelectGet 统计数据总条数并查询多条数据, 通过反射把数据赋值到result (with *schema).
func (s *{{{.OriginNamePascal}}}) OfCountSelectGet(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), result interface{}, way ...*hey.Way) (count int64, err error) {
    count, err = s.OfCountSelect(ctx, query, func(get *hey.Get) error {
        return get.Get(&result)
    }, way...)
    return
}

// OfCountSelectMap 统计数据总条数并查询多条数据, 将数据存储到map[string]interface{}中 (with *schema).
func (s *{{{.OriginNamePascal}}}) OfCountSelectMap(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (count int64, result []map[string]interface{}, err error) {
    count, err = s.OfCountSelect(ctx, query, func(get *hey.Get) error {
        result, err = get.ViewMap()
        return err
    }, way...)
    return
}

// OfCountSelectMap1 统计数据总条数并查询多条数据, 将数据存储到map[string]interface{}中, 单独处理空值[]map[string]interface{} (with *schema).
func (s *{{{.OriginNamePascal}}}) OfCountSelectMap1(ctx context.Context, query func(get *hey.Get, f hey.Filter, t *model.{{{.OriginNamePascal}}}Schema), way ...*hey.Way) (count int64, result []map[string]interface{}, err error) {
    count, result, err = s.OfCountSelectMap(ctx, query, way...)
    if err != nil {
        return 0, nil, err
    }
    if result == nil {
        result = make([]map[string]interface{}, 0)
    }
    return count, result, nil
}

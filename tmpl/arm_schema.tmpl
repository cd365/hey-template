// hey-template version: {{{.Version}}}

package arm

import (
    "encoding/hex"
    "errors"
    "fmt"
	"github.com/cd365/hey"
	"regexp"
    "strconv"
	"strings"
)

const (
	// MaxBatch 批量操作允许的最大数
    MaxBatch = 500
)

// OfField 查询字段列表
type OfField struct {
	Field *string `json:"field" query:"field" form:"field" validate:"omitempty,min=1,max=1000"` // 查询字段列表(多个字段使用","分割)
}

// OfKeyword 搜索关键字
type OfKeyword struct {
	Keyword *string `json:"keyword" query:"keyword" form:"keyword" validate:"omitempty,min=1,max=32"` // 检索关键字
}

func (s OfKeyword) GetKeyword() string {
	return fmt.Sprintf("%%%s%%", *s.Keyword)
}

// OfWhere 检索条件过滤
type OfWhere struct {
	Filter *string `json:"filter" query:"filter" form:"filter" validate:"omitempty,min=1,max=8192"` // 条件过滤
}

// filterRegexp [数据类型:][条件类型:]字段名:[条件值]
// 条件值存在多个使用","分割, 为了防止数据出错,条件值时用16进制的数据
var filterRegexp = regexp.MustCompile(`^([fs]:)?([0-9]{2}:)?([a-zA-Z][a-zA-Z0-9_]*):([0-9A-Fa-f]*)?$`)

/*
数据类型限定:
-    -> 缺省默认整型 int64
"f:" -> float64
"s:" -> string

条件类型控制:
-   -> 缺省默认使用IN,当值的列表只有一个元素的时候自动使用=
01: -> NOT IN
02: -> BETWEEN AND
03: -> NOT BETWEEN AND
04: -> >
05: -> >=
06: -> <
06: -> <=
08: -> LIKE
09: -> NOT LIKE
10: -> IS NULL
11: -> IS NOT NULL
*/

func integer3(bts []byte) ([]interface{}, error) {
	splits := strings.Split(string(bts), ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		i64, err := strconv.ParseInt(splits[i], 10, 64)
		if err != nil {
			return nil, err
		}
		result = append(result, i64)
	}
	return result, nil
}

func double3(bts []byte) ([]interface{}, error) {
	splits := strings.Split(string(bts), ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		f64, err := strconv.ParseFloat(splits[i], 64)
		if err != nil {
			return nil, err
		}
		result = append(result, f64)
	}
	return result, nil
}

func number3(bts []byte, floatValue bool) ([]interface{}, error) {
	if floatValue {
		return double3(bts)
	}
	return integer3(bts)
}

func string3(bts []byte) []interface{} {
	splits := strings.Split(string(bts), ",")
	length := len(splits)
	result := make([]interface{}, 0, length)
	for i := 0; i < length; i++ {
		result = append(result, splits[i])
	}
	return result
}

func (s OfWhere) match() ([][][]string, error) {
	if s.Filter == nil || *s.Filter == "" {
		return nil, nil
	}
	queries := strings.Split(*s.Filter, ",")
	length := len(queries)
	matched := make([][][]string, 0, length)
	for i := 0; i < length; i++ {
		item, err := hex.DecodeString(queries[i])
		if err != nil {
			return nil, err
		}
		tmp := filterRegexp.FindAllStringSubmatch(string(item), -1)
		if tmp == nil {
			continue
		}
		matched = append(matched, tmp)
	}
	return matched, nil
}

var (
	ErrInvalidFilterValue = errors.New("invalid filter value")
)

// GetWhere 解析检索条件 ---> 使用","切割多个被 hex.EncodeToString([]byte(v)) 的字符串, v是满足 filterRegexp 正则表达式的条件字符串
func (s OfWhere) GetWhere(fieldsLimitAndRename ...map[string]string) (hey.Filter, error) {
	matched, err := s.match()
	if err != nil {
		return nil, err
	}
	count := len(matched)
	if count == 0 {
		return nil, nil
	}

	var fields map[string]string
	{
		length := len(fieldsLimitAndRename)
		for i := 0; i < length; i++ {
			if fieldsLimitAndRename[i] == nil {
				continue
			}
			if fields == nil {
				fields = fieldsLimitAndRename[i]
				continue
			}
			for k, v := range fieldsLimitAndRename[i] {
				fields[k] = v
			}
		}
	}

	var bts []byte
	var field string         // 字段名
	var values []interface{} // 字段值
	var group []string       // [SF][0-9]field:[values]

	filter := hey.F()

	length := len(matched)
	for i := 0; i < length; i++ {
		group = matched[i][0]
		field = group[3]
		if fields != nil {
			tmp, ok := fields[field]
			if !ok {
				continue
			}
			if tmp != "" {
				field = tmp // field name redress
			}
		}
		// 提取字段值列表
		if group[4] != "" {
			if bts, err = hex.DecodeString(group[4]); err != nil {
				return nil, err
			}
		}
		if bts != nil {
			switch group[1] {
			case "f:": // float64
				values, err = number3(bts, true)
				if err != nil {
					return nil, err
				}
			case "s:": // string
				values = string3(bts)
			default: // int
				values, err = number3(bts, false)
				if err != nil {
					return nil, err
				}
			}
		}

		// 根据条件运算符 提取参数值列表
		switch group[2] {
		default:
			filter.In(field, values...)
		case "01:":
			filter.NotIn(field, values...)
		case "02:":
			if len(values) != 2 {
				return nil, ErrInvalidFilterValue
			}
			filter.Between(field, values[0], values[1])
		case "03:":
			if len(values) != 2 {
				return nil, ErrInvalidFilterValue
			}
			filter.NotBetween(field, values[0], values[1])
		case "04:":
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.Greater(field, values[0])
		case "05:":
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.GreaterEqual(field, values[0])
		case "06:":
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.LessThan(field, values[0])
		case "07:":
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.LessThanEqual(field, values[0])
		case "08:":
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.Like(field, fmt.Sprintf("%%%s%%", values[0]))
		case "09:":
			if len(values) == 0 {
				return nil, ErrInvalidFilterValue
			}
			filter.NotLike(field, fmt.Sprintf("%%%s%%", values[0]))
		case "10:":
			filter.IsNull(field)
		case "11:":
			filter.IsNotNull(field)
		}
	}

	return filter, nil
}

// OfMinMaxId 最大索引值,用于查询(表中数据条数超过OfLimitOffset.Offset值时的查询) 根据索引值倒序查询
type OfMinMaxId struct {
	// MinId 最小索引值,用于查询(表中数据条数超过OfLimitOffset.Offset值时的查询) 根据索引值顺序查询
	// SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id > 5000000 ) ORDER BY id DESC )
	MinId *int64 `json:"min_id,string" query:"min_id" form:"mid_id" validate:"omitempty"` // 最小id值,不包含当前值

	// MaxId 最大索引值,用于查询(表中数据条数超过OfLimitOffset.Offset值时的查询) 根据索引值倒序查询
	// SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
	MaxId *int64 `json:"max_id,string" query:"max_id" form:"max_id" validate:"omitempty"` // 最大id值,不包含当前值
}

// OfCount 统计满足条件的总条数
type OfCount struct {
	IsCount bool  `json:"count" query:"count" form:"count" validate:"-"` // 是否统计总条数
	Count   int64 `json:"-" query:"-" form:"-" validate:"-"`             // 查到的数据总条数
}

// OfOrder 检索数据排序
type OfOrder struct {
	Order *string `json:"order" query:"order" form:"order" validate:"omitempty,min=1,max=255"` // 排序
}

func (s OfOrder) GetOrder() string {
	if s.Order == nil || *s.Order == "" {
		return ""
	}
	*s.Order = strings.TrimSpace(*s.Order)
	if bts, err := hex.DecodeString(*s.Order); err == nil {
		return string(bts)
	}
	return *s.Order
}

// OfLimitOffset 控制数据列表返回的数据;如果数据超过offset的最大值,应该考虑换个方式查询分页数据如: SELECT id, name FROM ( SELECT id, name FROM account WHERE ( id < 5000000 ) ORDER BY id DESC )
type OfLimitOffset struct {
	Limit  int64 `json:"limit" query:"limit" form:"limit" validate:"omitempty,min=1,max=1000"`      // 数据条数
	Offset int64 `json:"offset" query:"offset" form:"offset" validate:"omitempty,min=0,max=100000"` // 数据偏移量
}

func (s OfLimitOffset) GetLimit() int64 {
	if s.Limit <= 0 {
		return 1
	}
	return s.Limit
}

func (s OfLimitOffset) GetOffset() int64 {
	if s.Offset < 0 {
		return 0
	}
	return s.Offset
}

type GetQuery struct {
	OfField
	OfWhere
	OfMinMaxId
	OfCount
	OfOrder
	OfLimitOffset
	fieldMap map[string]string // 字段名替换, 可能存在表名前缀或者使用别名的情况, 故使用当前map进行替换 map[传入字段名]真实使用字段名
	joins    []*hey.GetJoin    // 自定义连接查询(默认使用连接查询,主表默认别名为"a")
	whereMap map[string]string // 替换WHERE条件中字段名(与字段名属性类似)
	orderMap map[string]string // 替换ORDER排序中的字段名(与字段名属性类似)
	ident    *hey.Ident        // 主表别名信息
	result   interface{}       // 接收检索结果的对象
	total    *int64            // 查询到的数据总条数
}

func NewGetQuery() *GetQuery {
	return &GetQuery{}
}

func (s *GetQuery) SetFieldMap(fieldMap map[string]string) *GetQuery {
	s.fieldMap = fieldMap
	return s
}

func (s *GetQuery) GetFieldMap() map[string]string {
	return s.fieldMap
}

func (s *GetQuery) AddFieldMap(fieldMap map[string]string) *GetQuery {
	return s.SetFieldMap(hey.MergeMap(s.GetFieldMap(), fieldMap))
}

func (s *GetQuery) SetField(field ...string) *GetQuery {
	fields := strings.Join(field, ",")
	s.Field = &fields
	return s
}

func (s *GetQuery) GetField() []string {
	if s.Field == nil || *s.Field == "" {
		return nil
	}
	fieldsString := *s.Field
	if bts, err := hex.DecodeString(*s.Field); err == nil {
		fieldsString = string(bts)
	}
	fields := strings.Split(fieldsString, ",")
	fieldMap := s.GetFieldMap()
	if fieldMap == nil {
		return fields
	}
	for k, v := range fields {
		if tmp, ok := fieldMap[v]; ok {
			fields[k] = tmp
		}
	}
	return fields
}

func (s *GetQuery) AddField(field ...string) *GetQuery {
	return s.SetField(*s.Field, strings.Join(field, ","))
}

func (s *GetQuery) SetJoins(joins ...*hey.GetJoin) *GetQuery {
	s.joins = joins
	return s
}

func (s *GetQuery) GetJoins() []*hey.GetJoin {
	return s.joins
}

func (s *GetQuery) SetWhereMap(whereMap map[string]string) *GetQuery {
	s.whereMap = whereMap
	return s
}

func (s *GetQuery) GetWhereMap() map[string]string {
	return s.whereMap
}

func (s *GetQuery) AddWhereMap(whereMap map[string]string) *GetQuery {
	return s.SetWhereMap(hey.MergeMap(s.GetWhereMap(), whereMap))
}

func (s *GetQuery) SetOrderMap(orderMap map[string]string) *GetQuery {
	s.orderMap = orderMap
	return s
}

func (s *GetQuery) GetOrderMap() map[string]string {
	return s.orderMap
}

func (s *GetQuery) SetIdent(ident *hey.Ident) *GetQuery {
	s.ident = ident
	return s
}

func (s *GetQuery) GetIdent() *hey.Ident {
	return s.ident
}
